import { MIDUFACE } from './logos.ts';
import type { Config, BiProblemDescription } from "./types.d.ts";

export const MIDU_LINKS = {
    website: "https://midu.dev",
    twitch: "https://twitch.tv/midudev",
    youtube: "https://youtube.com/midudev",
    twitter: "https://twitter.com/midudev",
    github: "https://github.com/midudev",
}

export const ABOUT_THE_AUTHOR = (lang = "en") => lang === 'en' ? `
${MIDUFACE}

Miguel √Ångel Dur√°n Garc√≠a, also known as Midudev is a Software Engineer
with more than 15 years of experience in the industry. He is now focused on
creating content for developers and helping them to grow in their careers,
mostly in the Latin American community.

He is streaming on Twitch from Monday to Thursday at 12:00 PM (UTC-5) and
creating content on YouTube and other platforms. He is also a Google Developer
Expert in Web Technologies and a GitHub Star.

You can find him on:
` : `
${MIDUFACE}

Miguel √Ångel Dur√°n Garc√≠a, tambi√©n conocido como Midudev es un Ingeniero de
Software con m√°s de 15 a√±os de experiencia en la industria. Ahora est√° enfocado
en crear contenido para desarrolladores y ayudarlos a crecer en sus carreras,
principalmente en la comunidad latinoamericana.

Est√° transmitiendo en Twitch de lunes a jueves a las 12:00 PM (UTC-5) y
creando contenido en YouTube y otras plataformas. Tambi√©n es un Google Developer
Expert en Tecnolog√≠as Web y una GitHub Star.

Puedes encontrarlo en:
`;

export const DESCRIPTION = (lang = 'en') => lang === 'en' ? `

The Advent JS is an iniatitive by @midudev, Miguel √Ångel Dur√°n Garc√≠a

Check out the official website: https://adventjs.dev/

This version is designed to test your solutions locally before submitting them to the platform.
Your code will be tested against the public test cases and in some cases against some random test cases.
You can use wheter JavaScript or TypeScript to solve the problems.
This description will be shown once the CLI is executed for the first time, after that, you
can choose the option to create a config file for the CLI with this option disabled by default.

This CLI will help you to:
- Create a new problem solution template to fast start
- Read the problem description
- Test your solution
- Focus on solving the problem in a local environment before submitting it to the platform
- Avoid code overhead by setting up a repository to share your solutions
` : `
El Advent JS es una iniciativa de @midudev, Miguel √Ångel Dur√°n Garc√≠a

Echa un vistazo al sitio web oficial: https://adventjs.dev/

Esta versi√≥n est√° dise√±ada para probar tus soluciones localmente antes de enviarlas a la plataforma.
Tu c√≥digo ser√° probado contra los casos de prueba p√∫blicos y en algunos casos contra algunos casos de prueba aleatorios.
Puedes usar JavaScript o TypeScript para resolver los problemas.
Esta descripci√≥n se mostrar√° una vez que se ejecute la CLI por primera vez, despu√©s de eso, puedes
elegir la opci√≥n de crear un archivo de configuraci√≥n para la CLI con esta opci√≥n deshabilitada de forma predeterminada.

Esta CLI te ayudar√° a:
- Crear una nueva plantilla de soluci√≥n de problemas para comenzar r√°pidamente
- Leer la descripci√≥n del problema
- Probar tu soluci√≥n
- Enfocarte en resolver el problema en un entorno local antes de enviarlo a la plataforma
- Evitar exceso de c√≥digo al configurar un repositorio para compartir tus soluciones
`;

export const INITIAL_CONFIG = (lang = 'en'): Config => lang === 'en'
    ? {
        language: "es",
        version: "2023",
        flavor: "js",
        showDescription: true,
    }
    : {
        language: "es",
        version: "2023",
        flavor: "js",
        showDescription: true,
    };

export const PROBLEMS: Record<number, BiProblemDescription> = {
    1: {
        "title": {
            "en": "Challenge #1: üéÅ First gift repeated!",
            "es": "Reto #1: üéÅ ¬°Primer regalo repetido!"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In the toy factory of the North Pole, each toy has a unique identification numbe\nr.\nHowever, due to an error in the toy machine, some numbers have been assigned to \nmore than one toy.\nFind the first identification number that has been repeated, where the second oc\ncurrence has the smallest index!\nIn other words, if there is more than one repeated number, you must return the n\number whose second occurrence appears first in the list. If there are no repeate\nd numbers, return -1.\n\nWatch out! The elves say this is a Google technical test.",
            "es": "En la f√°brica de juguetes del Polo Norte, cada juguete tiene un n√∫mero de identi\nficaci√≥n √∫nico.\nSin embargo, debido a un error en la m√°quina de juguetes, algunos n√∫meros se han\n asignado a m√°s de un juguete.\n¬°Encuentra el primer n√∫mero de identificaci√≥n que se ha repetido, donde la segun\nda ocurrencia tenga el √≠ndice m√°s peque√±o!\nEn otras palabras, si hay m√°s de un n√∫mero repetido, debes devolver el n√∫mero cu\nya segunda ocurrencia aparezca primero en la lista. Si no hay n√∫meros repetidos,\n devuelve -1.\n\n¬°Ojo! Los elfos dicen que esto es una prueba t√©cnica de Google."
        },
        "code": "const giftIds = [2, 1, 3, 5, 3, 2]\nconst firstRepeatedId = findFirstRepeated(giftIds)\nconsole.log(firstRepeatedId) // 3\n// Even though 2 and 3 are repeated\n// 3 appears second time first\n\nconst giftIds2 = [1, 2, 3, 4]\nconst firstRepeatedId2 = findFirstRepeated(giftIds2)\nconsole.log(firstRepeatedId2) // -1\n// It is -1 since no number is repeated\n\nconst giftIds3 = [5, 1, 5, 1]\nconst firstRepeatedId3 = findFirstRepeated(giftIds3)\nconsole.log(firstRepeatedId3) // 5\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/1\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/1\n"
        }
    },
    2: {
        "title": {
            "en": "Challenge #2: üè≠ We start the factory",
            "es": "Reto #2: üè≠ Ponemos en marcha la f√°brica"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In Santa's workshop, the elves have a gift list they wish to make and a limited \nset of materials.\nGifts are strings of text and materials are characters. Your task is to write a \nfunction that, given a list of gifts and the available materials, returns a list\n of the gifts that can be made.\nA gift can be made if we have all the necessary materials to make it.\n",
            "es": "En el taller de Santa, los elfos tienen una lista de regalos que desean fabricar\n y un conjunto limitado de materiales.\nLos regalos son cadenas de texto y los materiales son caracteres. Tu tarea es es\ncribir una funci√≥n que, dada una lista de regalos y los materiales disponibles, \ndevuelva una lista de los regalos que se pueden fabricar.\nUn regalo se puede fabricar si contamos con todos los materiales necesarios para\n fabricarlo.\n"
        },
        "code": "const gifts = ['tren', 'oso', 'pelota']\nconst materials = 'tronesa'\n\nmanufacture(gifts, materials) // [\"tren\", \"oso\"]\n\nconst gifts = ['juego', 'puzzle']\nconst materials = 'jlepuz'\n\nmanufacture(gifts, materials) // [\"puzzle\"]\n\nconst gifts = ['libro', 'ps5']\nconst materials = 'psli'\n\nmanufacture(gifts, materials) // []\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/2\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/2\n"
        }
    },
    3: {
        "title": {
            "en": "Challenge #3: üòè The naughty elf",
            "es": "Reto #3: üòè El elfo travieso"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In Santa's workshop, a mischievous elf has been playing around with the gift pro\nduction line, adding or removing an unplanned step.\nYou have the original sequence of original manufacturing steps and the modified \nmodified sequence that may include an extra step or be missing a step.\nYour task is to write a function that identifies and returns the first extra ste\np that was added or removed in the manufacturing chain. If there is no differenc\ne between the sequences, return an empty string.\n\nPlease, keep in mind:\n\nThere will always be one different step or none.\nThe modification can occur anywhere in the string.\nThe original steps could be empty\n",
            "es": "En el taller de Santa, un elfo travieso ha estado jugando en la cadena de fabric\naci√≥n de regalos, a√±adiendo o eliminando un paso no planificado.\nTienes la secuencia original de pasos en la fabricaci√≥n original y la secuencia \nmodificada modified que puede incluir un paso extra o faltar un paso.\nTu tarea es escribir una funci√≥n que identifique y devuelva el primer paso extra\n que se ha a√±adido o eliminado en la cadena de fabricaci√≥n. Si no hay ninguna di\nferencia entre las secuencias, devuelve una cadena vac√≠a.\n\nA tener en cuenta:\n\nSiempre habr√° un paso de diferencia o ninguno.\nLa modificaci√≥n puede ocurrir en cualquier lugar de la cadena.\nLa secuencia original puede estar vac√≠a\n"
        },
        "code": "const original = 'abcd'\nconst modified = 'abcde'\nfindNaughtyStep(original, modified) // 'e'\n\nconst original = 'stepfor'\nconst modified = 'stepor'\nfindNaughtyStep(original, modified) // 'f'\n\nconst original = 'abcde'\nconst modified = 'abcde'\nfindNaughtyStep(original, modified) // ''\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/3\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/3\n"
        }
    },
    4: {
        "title": {
            "en": "Challenge #4: üòµ‚Äçüí´ Turn the parentheses around",
            "es": "Reto #4: üòµ‚Äçüí´ Dale la vuelta a los par√©ntesis"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In üéÖ Santa's workshop, some Christmas messages have been written in a peculiar \nway: the words within the brackets must be read backwards.\nSanta needs these messages to be correctly formatted. Your task is to write a fu\nnction that takes a string and reverses the characters within each pair of paren\ntheses, removing the parentheses as well.\nHowever, bear in mind that there may be nested parentheses, so you should revers\ne the characters in the correct order.\n\nNotes:\n\nThe input strings will always be well formed with parentheses that match correct\nly, you do not need to validate them.\nThere should not be any parentheses left in the final message.\nThe maximum nesting level is 2.\n",
            "es": "En el taller de Santa üéÖ, algunos mensajes navide√±os han sido escritos de manera\n peculiar: las letras dentro de los par√©ntesis deben ser le√≠das al rev√©s\nSanta necesita que estos mensajes est√©n correctamente formateados. Tu tarea es e\nscribir una funci√≥n que tome una cadena de texto y revierta los caracteres dentr\no de cada par de par√©ntesis, eliminando los par√©ntesis en el mensaje final.\nEso s√≠, ten en cuenta que pueden existir par√©ntesis anidados, por lo que debes i\nnvertir los caracteres en el orden correcto.\n\nNotas:\n\nLas cadenas de entrada siempre estar√°n bien formadas con par√©ntesis que coincide\nn correctamente, no necesitas validarlos.\nEn el mensaje final no deben quedar par√©ntesis.\nEl nivel m√°ximo de anidamiento es 2.\n"
        },
        "code": "const a = decode('hola (odnum)')\nconsole.log(a) // hola mundo\n\nconst b = decode('(olleh) (dlrow)!')\nconsole.log(b) // hello world!\n\nconst c = decode('sa(u(cla)atn)s')\nconsole.log(c) // santaclaus\n\n// Step by step:\n// 1. Reverse the nested -> sa(ualcatn)s\n// 2. Reverse the remaining one -> santaclaus\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/4\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/4\n"
        }
    },
    5: {
        "title": {
            "en": "Challenge #5: üõ∑ Santa's CyberTruck",
            "es": "Reto #5: üõ∑ El CyberTruck de Santa"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "Santa üéÖ is testing his new electric sled, the CyberReindeer, on a North Pole ro\nad. The road is represented by a string of characters, where:\n\n. = Road\nS = Santa's Sled\n* = Open barrier\n| = Closed barrier\n\nExample of a road: S...|....|.....\nEach unit of time, the sled moves one position to the right. If it encounters a \nclosed barrier, it stops until the barrier opens. If it is open, it goes through\n directly.\nAll barriers start closed, but after 5 units of time, they all open forever.\nCreate a function that simulates the sled's movement for a given time and return\ns an array of strings representing the state of the road at each unit of time:\n\nThe result is an array where each element shows the road at each unit of time.\nTake into account that if the sled is in the same position as a barrier, then it\n takes its place in the array.\nThe elves were inspired by this Code Wars challenge.",
            "es": "Santa üéÖ est√° probando su nuevo trineo el√©ctrico, el CyberReindeer, en una carre\ntera del Polo Norte. La carretera se representa con una cadena de caracteres, do\nnde:\n\n. = Carretera\nS = Trineo de Santa\n* = Barrera abierta\n| = Barrera cerrada\n\nEjemplo de carretera: S...|....|.....\nCada unidad de tiempo, el trineo avanza una posici√≥n a la derecha. Si encuentra \nuna barrera cerrada, se detiene hasta que la barrera se abra. Si est√° abierta, l\na atraviesa directamente.\nTodas las barreras empiezan cerradas, pero despu√©s de 5 unidades de tiempo, se a\nbren todas para siempre.\nCrea una funci√≥n que simule el movimiento del trineo durante un tiempo dado y de\nvuelva un array de cadenas representando el estado de la carretera en cada unida\nd de tiempo:\n\nEl resultado es un array donde cada elemento muestra la carretera en cada unidad\n de tiempo.\nTen en cuenta que si el trineo est√° en la misma posici√≥n que una barrera, entonc\nes toma su lugar en el array.\nLos elfos se inspiraron en este reto de Code Wars."
        },
        "code": "const road = 'S..|...|..'\nconst time = 10 // units of time\nconst result = cyberReindeer(road, time)\n\n/* -> result:\n[\n  'S..|...|..', // initial state\n  '.S.|...|..', // sled advances on the road\n  '..S|...|..', // sled advances on the road\n  '..S|...|..', // sled stops at the barrier\n  '..S|...|..', // sled stops at the barrier\n  '...S...*..', // barrier opens, sled advances\n  '...*S..*..', // sled advances on the road\n  '...*.S.*..', // sled advances on the road\n  '...*..S*..', // sled advances on the road\n  '...*...S..', // passes through the open barrier\n]\n*/\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/5\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/5\n"
        }
    },
    6: {
        "title": {
            "en": "Challenge #6: ü¶å The reindeer on trial",
            "es": "Reto #6: ü¶å Los renos a prueba"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "The elves are cataloging Santa's reindeer ü¶å based on the distance they can trav\nel.\nFor this, they have a text string movements where each character represents the \ndirection of the reindeer's movement:\n\n> = Moves to the right\n< = Moves to the left\n* = Can move forward or backward\n\nFor example, if the movement is >>*<, it goes to the right twice, then it can go\n either left or right (whichever maximizes the final traveled distance) and then\n left.\nThe elves want to know what the maximum distance the reindeer travels is after c\nompleting all movements.\nIn the previous example, the maximum distance the reindeer travels is 2. It goes\n to the right twice +2, then with the * it can go to the right again to maximize\n the distance +1 and then it goes to the left -1.\nCreate a maxDistance function that takes the text string movements and returns t\nhe maximum distance that the reindeer can travel in any direction:\n\nKeep in mind that it doesn't matter whether it is to the left or right, the dist\nance is the absolute value of the maximum distance traveled at the end of the mo\nvements.",
            "es": "Los elfos est√°n catalogando los renos de Santa ü¶å seg√∫n la distancia que pueden \nrecorrer.\nPara ello tienen una cadena de texto movements donde cada caracter representa la\n direcci√≥n del movimiento del reno:\n\n> = Avanza a la derecha\n< = Avanza a la izquierda\n* = Puede avanzar o retroceder\n\nPor ejemplo, si el movimiento es >>*<, va hacia la derecha dos veces, luego pued\ne ir a derecha o izquierda (lo que maximice la distancia recorrida final) y lueg\no ir a la izquierda.\nLos elfos quieren saber cu√°l es la m√°xima distancia que recorre el reno al final\nizar todos los movimientos.\nEn el ejemplo anterior, la m√°xima distancia que recorre el reno es 2. Va a la de\nrecha dos veces +2, luego con el * puede ir a la derecha otra vez para maximizar\n la distancia +1 y luego va a la izquierda -1.\nCrea una funci√≥n maxDistance que reciba la cadena de texto movements y devuelva \nla m√°xima distancia que puede recorrer el reno en cualquier direcci√≥n:\n\nTen en cuenta que no importa si es a la izquierda o la derecha, la distancia es \nel valor absoluto de la distancia recorrida m√°xima al finalizar los movimientos."
        },
        "code": "const movements = '>>*<'\nconst result = maxDistance(movements)\nconsole.log(result) // -> 2\n\nconst movements2 = '<<<>'\nconst result2 = maxDistance(movements2)\nconsole.log(result2) // -> 2\n\nconst movements3 = '>***>'\nconst result3 = maxDistance(movements3)\nconsole.log(result3) // -> 5\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/6\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/6\n"
        }
    },
    7: {
        "title": {
            "en": "Challenge #7: üì¶ The 3D boxes",
            "es": "Reto #7: üì¶ Las cajas en 3D"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "Santa is experimenting with new gift designs and he needs your help to visualize\n them in 3D.\nYour task is to write a function that, given a size n (integer), generates a dra\nwing of a 3D gift using ASCII characters.\nThe lines of the gifts are drawn with # and the faces with the symbol passed to \nus as a parameter:\n\nImportant: We have been told that there is always to leave a newline at the end \nof the drawing.",
            "es": "Santa est√° experimentando con nuevos dise√±os de regalos y necesita tu ayuda para\n visualizarlos en 3D.\nTu tarea es escribir una funci√≥n que, dado un tama√±o n (entero), genere un dibuj\no de un regalo en 3D utilizando caracteres ASCII.\nLas l√≠neas de los regalos se dibujan con # y las caras con el s√≠mbolo que nos pa\nsan como par√°metro:\n\nImportante: Nos han dicho que siempre hay que dejar un salto de l√≠nea al final d\nel dibujo.\nNota: Ten en cuenta que, en los tests, la primera l√≠nea se ve empujada por el ca\nracter \"."
        },
        "code": "drawGift(4, '+')\n\n/*\n   ####\n  #++##\n #++#+#\n####++#\n#++#+#\n#++##\n####\n*/\n\ndrawGift(5, '*')\n/*\n    #####\n   #***##\n  #***#*#\n #***#**#\n#####***#\n#***#**#\n#***#*#\n#***##\n#####\n*/\n\ndrawGift(1, '^')\n/*\n#\n*/\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/7\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/7\n"
        }
    },
    8: {
        "title": {
            "en": "Challenge #8: üè¨ Sorting the warehouse",
            "es": "Reto #8: üè¨ Ordenando el almac√©n"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "The elves are very busy in Santa Claus' workshop organizing gifts üéÅ for Christm\nas Eve üéÑ.\nThe input format is special, as it indicates the number of gifts and the type of\n gift with letters from a to z. For example, '66a11b' means 66 a gifts and 11 b \ngifts.\nThe elves have a special system for organizing the gifts:\n\nEvery 10 gifts of the same type are packed in a box, represented by {x}. For exa\nmple, 20 type a gifts are packed in two boxes like this: {a}{a}.\nEvery 5 boxes are stacked on a pallet, represented by [x]. For example, 10 a box\nes are stacked on 2 pallets in this way: [a][a]\nAny additional gift is placed in a bag, represented by () and all of them are pl\naced inside. For example, 4 b gifts are placed in a bag like this (bbbb)\n\nThe gifts are then placed in the following order: pallets, boxes and bags. And t\nhe gifts appear in the same order as the input string.\nYour task is to write a function organizeGifts that takes a string of gifts as a\nn argument and returns a string representing the warehouse.\n",
            "es": "Los elfos est√°n muy ocupados en el taller de Santa Claus organizando regalos üéÅ \npara la v√≠spera de Navidad üéÑ.\nEl formato de entrada es especial, ya que indica el n√∫mero de regalos y el tipo \nde regalo con letras de la a a la z. Por ejemplo, '66a11b' significa 66 regalos \na y 11 regalos b.\nLos elfos tienen un sistema especial para organizar los regalos:\n\nCada 10 regalos del mismo tipo se empaquetan en una caja, representada por {x}. \nPor ejemplo, 20 regalos tipo a se empaquetan en 2 cajas as√≠: {a}{a}.\nCada 5 cajas se apilan en un pal√©, representado por [x]. Por ejemplo, 10 cajas d\ne a se apilan en 2 pal√©s de esta manera: [a][a]\nCualquier regalo adicional se coloca en una bolsa, representada por () y se colo\ncan todas dentro. Por ejemplo 4 regalos de b se colocan en una bolsa as√≠ (bbbb)\n\nLos regalos luego se colocan en el siguiente orden: pal√©s, cajas y bolsas. Y los\n regalos aparecen en el mismo orden que la cadena de entrada.\nTu tarea es escribir una funci√≥n organizeGifts que tome una cadena de regalos co\nmo argumento y devuelva una cadena representando el almac√©n.\n"
        },
        "code": "const result1 = organizeGifts('76a11b')\nconsole.log(result1)\n// `[a]{a}{a}(aaaaaa){b}(b)`\n\n/* Explanation:\n\n  76a: 76 gifts type 'a' would be packed in 7 boxes and 6 gifts would be left, resulting in 1 pallet [a] (for the first 5 boxes), 2 loose boxes {a}{a} and a bag with 6 gifts (aaaaaa)\n\n  11b: 11 gifts type 'b' would be packed in 1 box and 1 gift would be left, resulting in 1 loose box {b} and a bag with 1 gift (b)\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/8\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/8\n"
        }
    },
    9: {
        "title": {
            "en": "Challenge #9: üö¶ Switch the lights",
            "es": "Reto #9: üö¶ Alterna las luces"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "They are turning on the Christmas lights üéÑ in the city and, as every year, they\n have to be fixed!\nThe lights are of two colors: üî¥ and üü¢ . For the effect to be appropriate, they\n must always alternate. That is, if the first light is red, the second must be g\nreen, the third red, the fourth green, etc.\nWe have been asked to write a function adjustLights that, given an array of stri\nngs with the color of each light, return the minimum number of lights that need \nto be changed for the colors to alternate.\n",
            "es": "Est√°n encendiendo las luces de Navidad üéÑ en la ciudad y, como cada a√±o, ¬°hay qu\ne arreglarlas!\nLas luces son de dos colores: üî¥ y üü¢ . Para que el efecto sea el adecuado, siem\npre deben estar alternadas. Es decir, si la primera luz es roja, la segunda debe\n ser verde, la tercera roja, la cuarta verde, etc.\nNos han pedido que escribamos una funci√≥n adjustLights que, dado un array de str\nings con el color de cada luz (representados con los emojis üî¥ para el rojo y üü¢\n para el verde), devuelva el n√∫mero m√≠nimo de luces que hay que cambiar para que\n est√©n los colores alternos.\n"
        },
        "code": "adjustLights(['üü¢', 'üî¥', 'üü¢', 'üü¢', 'üü¢'])\n// -> 1 (you change the fourth light to üî¥)\n\nadjustLights(['üî¥', 'üî¥', 'üü¢', 'üü¢', 'üî¥'])\n// -> 2 (you change the second light to üü¢ and the third to üî¥)\n\nadjustLights(['üü¢', 'üî¥', 'üü¢', 'üî¥', 'üü¢'])\n// -> 0 (they are already alternating)\n\nadjustLights(['üî¥', 'üî¥', 'üî¥'])\n// -> 1 (you change the second light to üü¢)\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/9\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/9\n"
        }
    },
    10: {
        "title": {
            "en": "Challenge #10: üéÑ Create your own Christmas tree",
            "es": "Reto #10: üéÑ Crea tu propio √°rbol de navidad"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "What an idea Sam Elfman has had! He wants to offer a service that creates a cust\nomized Christmas tree üéÑ in a matter of seconds.\nTo create it, we are given a string to form the tree and a number that indicates\n its height.\nEach character of the string represents an ornament of the tree, and we use them\n cyclically until we reach the indicated height. At least, they will always pass\n us one.\nWe must return a multiline string with the Christmas tree made with the ornament\ns, the indicated height plus a final line with the trunk formed by the character\n | in the center and, finally, a newline \\n.\nFor example, if we receive the string \"123\" and the number 4 as height, we would\n have to build this tree:\n\nIf we receive the string *@o and the number 3, the tree we should return is:\n  *\n @ o\n* @ o\n  |\n\nNote:\n\nThe tree should always be centered, for that reason add blank spaces to the left\n of each line.\nCreate spaces only to the left of each line of the tree. Do not leave blank spac\nes to the right.\nThe ornaments have a white space between them for separation.\n",
            "es": "¬°Vaya idea ha tenido Sam Elfman! Quiere ofrecer un servicio que te crea un √°rbol\n de Navidad üéÑ personalizado en cuesti√≥n de segundos.\nPara crearlo nos pasan una cadena de caracteres para formar el √°rbol y un n√∫mero\n que indica la altura del mismo.\nCada car√°cter de la cadena representa un adorno del √°rbol, y vamos utiliz√°ndolos\n de forma c√≠clica hasta llegar a la altura indicada. Como m√≠nimo siempre nos pas\nar√°n uno.\nDebemos devolver un string multil√≠nea con el √°rbol de Navidad formado con los ad\nornos, la altura indicada m√°s una √∫ltima l√≠nea con el tronco formado por el car√°\ncter | en el centro y, finalmente, un salto de l√≠nea \\n.\nPor ejemplo si recibimos la cadena \"123\" y el n√∫mero 4 como altura, tendr√≠amos q\nue construir este √°rbol:\n\nSi recibimos la cadena *@o y el n√∫mero 3, el √°rbol que debemos devolver es:\n  *\n @ o\n* @ o\n  |\n\nNota:\n\nEl √°rbol siempre debe estar centrado, para ello a√±ade espacios en blanco a la iz\nquierda de cada l√≠nea.\nCrea espacios s√≥lo a la izquierda de cada l√≠nea del √°rbol. No dejes espacios en \nblanco a la derecha.\nLos adornos tienen un espacio en blanco entre ellos de separaci√≥n.\nSi te fallan los tests y visualmente parece que el √°rbol est√° bien, comprueba qu\ne no haya espacios en blanco que sobren, especialmente a la derecha de cada l√≠ne\na.\n"
        },
        "code": "   1\n  2 3\n 1 2 3\n1 2 3 1\n   |\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/10\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/10\n"
        }
    },
    11: {
        "title": {
            "en": "Challenge #11: üìñ The studious elves",
            "es": "Reto #11: üìñ Los elfos estudiosos"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In Santa's workshop, the elves love puzzles üß†. This year, they have created a s\npecial one: a challenge to form a Christmas palindrome.\nA palindrome is a word that reads the same forwards and backwards. The elves wan\nt to know if it is possible to form a palindrome by making, at most, one exchang\ne of letters.\nCreate a function get that receives a string and returns:\n\nIf it is already a palindrome, an empty array.\nIf it is not possible, null.\nIf a palindrome can be formed with one change, an array with the two positions (\nindexes) that must be swapped to create it.\n\nFor example:\n\nIf the palindrome can be formed with different swaps, always return the first on\ne found.",
            "es": "En el taller de Santa, los elfos aman los acertijos üß†. Este a√±o, han creado uno\n especial: un desaf√≠o para formar un pal√≠ndromo navide√±o.\nUn pal√≠ndromo es una palabra que se lee igual hacia adelante y hacia atr√°s. Los \nelfos quieren saber si es posible formar un pal√≠ndromo haciendo, como mucho, un \nintercambio de letras.\nCrea una funci√≥n get que reciba una cadena de caracteres y devolver√°:\n\nSi ya es un pal√≠ndromo, un array vac√≠o.\nSi no es posible, null.\nSi se puede formar un pal√≠ndromo con un cambio, un array con las dos posiciones \n(√≠ndices) que se deben intercambiar para poder crearlo.\n\nPor ejemplo:\n\nSi se puede formar el pal√≠ndromo con diferentes intercambios, siempre se debe de\nvolver el primero que se encuentre."
        },
        "code": "getIndexsForPalindrome('anna') // []\ngetIndexsForPalindrome('abab') // [0, 1]\ngetIndexsForPalindrome('abac') // null\ngetIndexsForPalindrome('aaaaaaaa') // []\ngetIndexsForPalindrome('aaababa') // [1, 3]\ngetIndexsForPalindrome('caababa') // null\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/11\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/11\n"
        }
    },
    12: {
        "title": {
            "en": "Challenge #12: üì∏ Is it a valid copy?",
            "es": "Reto #12: üì∏ ¬øEs una copia v√°lida?"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In the North Pole they still use paper photocopiers. Elves use them to copy the \nletters that children send to Santa, so they can send them to all the gift depar\ntments.\nHowever, they are very old and do not work very well. Every time they make a cop\ny, the quality of the copy slightly decreases, a phenomenon known as generation \nloss.\nYou need to detect if a letter is a copy of another. The letters are very long a\nnd you can't read them, but you can compare them with an algorithm.\nThere is a high probability that a character will degrade with each copy (it doe\nsn't always happen!). And when it happens, the rule it follows is:\n\nThe characters from A to Z degrade from capital letters to lower-case letters (A\n-Z ‚áí a-z)\nLetters degrade in a series of characters in this order: a-z ‚áí # ‚áí + ‚áí : ‚áí . ‚áí \nOnce the letters have degraded into the symbols, they can continue to degrade.\nNote that the last one is a blank space, not an empty character.\nCharacters that are not letters (like digits) do not degrade.\n\nKnowing this and receiving two letters. The supposed original and the copy. You \nmust determine if the copy is a copy of the other.\n\nTo understand how photocopiers and their degradation work, look at this example:\noriginal:  'Santa Claus'\n1st copy:  'santa cla#s'\n2nd copy:  'sa#t# cl#+s'\n3rd copy:  'sa+## c#+:s'\n4th copy:  's#++. c+:.s'\n5th copy:  's#+:. c:. s'\n\nTherefore s#+:. c+:++ is a valid copy of Santa Claus. And, as you see, the degra\ndation of the letters does not occur in a specific order, it is random.\nBased on the CodeWars challenge Photocopy decay",
            "es": "En el Polo Norte todav√≠a usan fotocopiadoras de papel. Los elfos las usan para c\nopiar las cartas que los ni√±os env√≠an a Santa y as√≠ poder enviarlas a todos los \ndepartamentos de regalos.\nSin embargo ya son muy viejas y no funcionan muy bien. Cada vez que hacen una co\npia, la calidad de la copia disminuye ligeramente, un fen√≥meno conocido como p√©r\ndida generacional.\nNecesitas detectar si una carta es una copia de otra. Las cartas son muy largas \ny no puedes leerlas, pero puedes compararlas con un algoritmo.\nExiste una gran probabilidad de que un caracter se degrade en cada copia (¬°no pa\nsa siempre!). Y al ocurrir, la regla que sigue es:\n\nLos caracteres de la A a la Z se degradan de may√∫sculas a min√∫sculas (A-Z ‚áí a-z)\nLas letras se degradan en una serie de caracteres en este orden: a-z ‚áí # ‚áí + ‚áí :\n ‚áí . ‚áí \nUna vez degradadas las letras en los s√≠mbolos, se pueden continuar degradando.\nTen en cuenta que el √∫ltimo es un espacio en blanco, no un caracter vac√≠o.\nLos caracteres que no son letras (como los d√≠gitos) no se degradan.\n\nSabiendo esto y recibiendo dos cartas. La supuesta original y la copia. Debes de\nterminar si la copia es una copia de la otra.\n\nPara entender c√≥mo funcionan las fotocopiadoras y su degradaci√≥n, mira este ejem\nplo:\noriginal:  'Santa Claus'\n1¬™ copia:  'santa cla#s'\n2¬™ copia:  'sa#t# cl#+s'\n3¬™ copia:  'sa+## c#+:s'\n4¬™ copia:  's#++. c+:.s'\n5¬™ copia:  's#+:. c:. s'\n\nPor lo tanto s#+:. c+:++ es una copia v√°lida de Santa Claus. Y, como ves, la deg\nradaci√≥n de las letras no se produce en un orden espec√≠fico, es aleatorio.\nBasado en el desaf√≠o de CodeWars Photocopy decay"
        },
        "code": "checkIsValidCopy(\n  'Santa Claus is coming',\n  'sa#ta Cl#us i+ comin#'\n) // true\ncheckIsValidCopy(\n  's#nta Cla#s is coming',\n  'p#nt: cla#s #s c+min#'\n) // false (due to the initial p)\ncheckIsValidCopy('Santa Claus', 's#+:. c:. s') // true\ncheckIsValidCopy('Santa Claus', 's#+:.#c:. s') // false (there is a # where it shouldn't be)\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/12\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/12\n"
        }
    },
    13: {
        "title": {
            "en": "Challenge #13: ‚åöÔ∏è Calculating the time",
            "es": "Reto #13: ‚åöÔ∏è Calculando el tiempo"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "The elves are preparing for Christmas Eve and they need your help to determine i\nf they have enough time or not ‚è≥.\nFor this, they give you an array with the duration of each delivery. The format \nof the duration is HH:mm:ss, the deliveries start at 00:00:00 and the time limit\n is 07:00:00.\nYour function must return the time they will lack or the time they will have lef\nt over in order to finish the deliveries. The format of the returned duration sh\nould be HH:mm:ss.\nIf they finish before 07:00:00, the remaining time until 07:00:00 should be disp\nlayed with a negative sign. For example, if they have 1 hour and 30 minutes left\n over, return -01:30:00\n",
            "es": "Los elfos est√°n preparando la v√≠spera de Navidad y necesitan tu ayuda para calcu\nlar si van sobrados o no de tiempo ‚è≥.\nPara ello te pasan un array con la duraci√≥n de cada entrega. El formato de la du\nraci√≥n es HH:mm:ss, las entregas empiezan a las 00:00:00 y el l√≠mite de tiempo e\ns 07:00:00.\nTu funci√≥n debe devolver el tiempo que les faltar√° o el tiempo que les sobrar√° p\nara terminar las entregas. El formato de la duraci√≥n devuelta debe ser HH:mm:ss.\nSi terminan antes de las 07:00:00, el tiempo restante hasta las 07:00:00 debe se\nr mostrado con un signo negativo. Por ejemplo, si sobran 1 hora y 30 minutos, de\nvuelve -01:30:00\n"
        },
        "code": "calculateTime(['00:10:00', '01:00:00', '03:30:00'])\n// '-02:20:00'\n\ncalculateTime(['02:00:00', '05:00:00', '00:30:00'])\n// '00:30:00'\n\ncalculateTime([\n  '00:45:00',\n  '00:45:00',\n  '00:00:30',\n  '00:00:30'\n]) // '-05:29:00'\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/13\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/13\n"
        }
    },
    14: {
        "title": {
            "en": "Challenge #14: üö® Avoid the alarm",
            "es": "Reto #14: üö® Evita la alarma"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "With the rise of social media, Santa Claus is terrified that children might wake\n up while he is delivering gifts in their homes, use their phone to record him a\nnd go viral on TikTok. \nHe wants to avoid this at all costs. Each house on that street has a number of p\nrepared gifts. However, the houses have a security system connected between adja\ncent houses, so he can't leave gifts in two consecutive houses, or the alarm wil\nl be triggered and alert the children.\nGiven an array of non-negative integers gifts that represents the number of gift\ns in each house, your task is to help Santa Claus determine the maximum number o\nf gifts he can deliver in one night without setting off any alarms.\n",
            "es": "Con el tema de las redes sociales, Santa Claus tiene p√°nico que los ni√±os se des\npierten mientras √©l est√° repartiendo regalos en sus casos, usen el m√≥vil para gr\nabarlo y se haga viral en TikTok.\nQuiere evitarlo a toda costa. Cada casa en esa calle tiene un n√∫mero de regalos \npreparados. Sin embargo, las casas tienen un sistema de seguridad conectado entr\ne casas adyacentes, por lo que no puede dejar los regalos en dos casas seguidas,\n o se activar√° la alarma que alertar√° a los ni√±os.\nDada un array de enteros no negativos regalos que representa la cantidad de rega\nlos en cada casa, tu tarea es ayudar a Pap√° Noel a determinar la m√°xima cantidad\n de regalos que puede entregar en una noche sin activar ninguna alarma.\n"
        },
        "code": "maxGifts([2, 4, 2]) // 4 (4)\nmaxGifts([5, 1, 1, 5]) // 10 (5 + 5)\nmaxGifts([4, 1, 1, 4, 2, 1]) // 9 (4 + 4 + 1)\nmaxGifts([1, 3, 1, 3, 100]) // 103 (3 + 100)\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/14\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/14\n"
        }
    },
    15: {
        "title": {
            "en": "Challenge #15: ‚ÜîÔ∏è Autonomous robot",
            "es": "Reto #15: ‚ÜîÔ∏è Robot aut√≥nomo"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "We are programming some robots called giftbot ü§ñüéÅ that autonomously navigate gi\nft warehouses.\nWe are creating a function to which we pass: the warehouse üè¨ they must navigate\n and the movements ‚ÜîÔ∏è they can make.\nThe warehouse is represented as an array of text strings, where:\n\n. means there is a clear path.\n* means there is an obstacle.\n! is the robot's initial position.\n\nThe movements are an array of text strings, where:\n\nR moves the robot one position to the right.\nL moves the robot one position to the left.\nU moves the robot one position upwards.\nD moves the robot one position downwards.\n\nIt must be taken into account that the robot cannot overcome obstacles or the wa\nrehouse boundaries.\nGiven a warehouse and the movements, we need to return the array with the robot'\ns final position.\n\nKeep in mind that the store is an array that can have a number of rows ranging f\nrom 1 to 100, as we have warehouses of all sizes.\nAlso note that the robot might end up in its initial position if it can't move o\nr if it's going around in circles.",
            "es": "Estamos programando unos robots llamados giftbot ü§ñüéÅ que navegan de forma aut√≥n\noma por los almacenes de regalos.\nEstamos creando una funci√≥n a la que le pasamos: el almac√©n üè¨ que deben navegar\n y los movimientos ‚ÜîÔ∏è que pueden realizar.\nEl almac√©n se representa como un array de cadenas de texto, donde:\n\n. significa que hay v√≠a libre.\n* significa que hay un obst√°culo.\n! es la posici√≥n inicial del robot.\n\nLos movimientos son un array de cadenas de texto, donde:\n\nR mueve al robot una posici√≥n a la derecha.\nL mueve al robot una posici√≥n a la izquierda.\nU mueve al robot una posici√≥n hacia arriba.\nD mueve al robot una posici√≥n hacia abajo.\n\nHay que tener en cuenta que el robot no puede superar los obst√°culos ni los l√≠mi\ntes del almac√©n.\nDados un almac√©n y los movimientos, debemos devolver el array con la posici√≥n fi\nnal de nuestro robot.\n\nTen en cuenta que la store es un array que puede ser de un n√∫mero de filas que v\na de 1 a 100, ya que tenemos almacenes de todos los tama√±os.\nTambi√©n que el robot es posible que termine en su posici√≥n inicial si no puede m\noverse o si est√° dando vueltas."
        },
        "code": "const store = ['..!....', '...*.*.']\n\nconst movements = ['R', 'R', 'D', 'L']\nconst result = autonomousDrive(store, movements)\nconsole.log(result)\n/*\n[\n  \".......\",\n  \"...*!*.\"\n]\n*/\n\n// The last movement is to the left, but it cannot move because there is an obstacle.\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/15\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/15\n"
        }
    },
    16: {
        "title": {
            "en": "Challenge #16: ‚ùå Friday deployment",
            "es": "Reto #16: ‚ùå Despliegue en viernes"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "Yesterday, someone did a production deployment and the application for assemblin\ng Christmas trees broke. We've been asked to fix it as soon as possible.\nThe problem is that the format of the trees has changed. It's an array of number\ns‚Ä¶ but it should be an object! For example, the tree: [3, 1, 0, 8, 12, null, 1] \nlooks like this:\n\nWhat we need is to transform the array into an object where each node of the tre\ne has value, left, and right properties.\nFor example, running your transformTree function with [3, 1, 0, 8, 12, null, 1] \nshould return this:\n{\n  value: 3,\n  left: {\n    value: 1,\n    left: {\n      value: 8,\n      left: null,\n      right: null\n    },\n    right: {\n      value: 12,\n      left: null,\n      right: null\n    }\n  },\n  right: {\n    value: 0,\n    left: null,\n    right: {\n      value: 1,\n      left: null,\n      right: null\n    }\n  }\n}\n\nThe elf on duty who tried to solve the problem before going home, left us some c\nlues:\n\nIf a node doesn't have a value, it's represented with null. Therefore, if a node\n has a null value, it won't have any children.\nThe root node is at index 0 in the array.\nThere's a relationship between the index of a node and the index of its children\n. Look for the pattern!\n",
            "es": "Ayer viernes alguien hizo despliegue a producci√≥n y se rompi√≥ la aplicaci√≥n de m\nontaje de √°rboles de Navidad. Nos han pedido que lo arreglemos lo antes posible.\nEl problema es que el formato de los √°rboles ha cambiado. Es un array de n√∫meros\n‚Ä¶ ¬°pero deber√≠a ser un objeto! Por ejemplo el √°rbol: [3, 1, 0, 8, 12, null, 1] s\ne ve as√≠:\n\nLo que necesitamos es transformar el array en un objeto donde cada nodo del √°rbo\nl tiene las propiedades value, left y right.\nPor ejemplo, al ejecutar tu funci√≥n transformTree con [3, 1, 0, 8, 12, null, 1] \ndeber√≠a devolver esto:\n{\n  value: 3,\n  left: {\n    value: 1,\n    left: {\n      value: 8,\n      left: null,\n      right: null\n    },\n    right: {\n      value: 12,\n      left: null,\n      right: null\n    }\n  },\n  right: {\n    value: 0,\n    left: null,\n    right: {\n      value: 1,\n      left: null,\n      right: null\n    }\n  }\n}\n\nEl elfo que est√° de guardia y que intent√≥ solucionar el problema antes de irse a\n casa, nos ha dejado algunas pistas:\n\nSi un nodo no tiene valor, se representa con null. Por lo tanto, si un nodo tien\ne valor null, no tendr√° hijos.\nEl nodo ra√≠z se encuentra en el √≠ndice 0 del array.\nExiste una relaci√≥n entre el √≠ndice de un nodo y el √≠ndice de sus hijos. ¬°Busca \nel patr√≥n!\n"
        },
        "code": "//        3\n//      /   \\\n//     1     0\n//    / \\     \\\n//   8  12     1\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/16\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/16\n"
        }
    },
    17: {
        "title": {
            "en": "Challenge #17: üõ∑ Optimizing the rental",
            "es": "Reto #17: üõ∑ Optimizando el alquiler"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In Rovaniemi, Finland üá´üáÆ, sleds üõ∑ are rented by time intervals. Each interval\n is represented as an array of two elements, where the first element is the star\nt of the rental and the second one is the end.\nFor example, the array [2, 7] represents a rental that begins at hour 2 and ends\n at hour 7. The problem is that sometimes the intervals overlap with each other,\n making it confusing to figure out from what time to what time the sled was rent\ned.\nWe're asked to, in order to simplify the task of calculating the total rental ti\nme, write a function that merges all overlapping intervals and returns an array \nof sorted intervals:\n\nYou can assume that the first element of each interval is always less than or eq\nual to the second element. But the intervals are not necessarily sorted.\nThe hour numbers can go up to the figure 9999.",
            "es": "En Rovaniemi, Finlandia üá´üáÆ, los trineos üõ∑ se alquilan por intervalos de tiemp\no. Cada intervalo se representa como un array de dos elementos, donde el primer \nelemento es el inicio del alquiler y el segundo es el final.\nPor ejemplo, el array [2, 7] representa un alquiler que comienza en la hora 2 y \ntermina en la hora 7. El problema es que a veces los intervalos se superponen en\ntre s√≠, haciendo que sea un l√≠o entender de qu√© hora a qu√© hora se alquil√≥ el tr\nineo.\nNos piden que, para simplificar la tarea de calcular el tiempo total de alquiler\n, escribamos una funci√≥n que fusione todos los intervalos superpuestos y devolve\nr un array de intervalos ordenados:\n\nPuedes asumir que el primer elemento de cada intervalo siempre es menor o igual \nque el segundo elemento. Pero los intervalos no est√°n necesariamente ordenados.\nLos n√∫meros de horas pueden llegar hasta la cifra 9999."
        },
        "code": "optimizeIntervals([\n  [5, 8],\n  [2, 7],\n  [3, 4]\n]) // [[2, 8]]\n\noptimizeIntervals([\n  [1, 3],\n  [8, 10],\n  [2, 6]\n]) // [[1, 6], [8, 10]]\n\noptimizeIntervals([\n  [3, 4],\n  [1, 2],\n  [5, 6]\n]) // [[1, 2], [3, 4], [5, 6]]\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/17\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/17\n"
        }
    },
    18: {
        "title": {
            "en": "Challenge #18: üî¢ The digital clock",
            "es": "Reto #18: üî¢ El reloj digital"
        },
        "level": {
            "en": "Level: Hard",
            "es": "Nivel: Dif"
        },
        "lvl_code": 2,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In the toy factory, the elves are programming a digital clock to keep them on sc\nhedule with gift production. However, they have encountered an interesting progr\namming challenge. They need a function that, given a time in 'HH:MM' format, cre\nates a visual representation of this time on a digital clock by returning an arr\nay of arrays of characters.\nThe clock screen has 7 rows and 17 columns, and each digit of the time takes up \n7 rows and 3 columns. The digits are composed of asterisks (*) and blank spaces \n(). There is an empty column between each digit.\nThe colon separating hours and minutes is drawn using two asterisks (*) and is a\nlways placed in the same position, in rows 2 and 4, in column 9, respectively (n\note: row and column indexing starts at 0).\nFor example, if the function receives 01:30, it should return:\n\nTo know how to draw each digit, we have been given the following image. As you c\nan see, each digit is composed of 7 rows and 3 columns. We will represent the pi\nxels in red with an asterisk (*), and the white pixels with a space ():\n",
            "es": "En la f√°brica de juguetes, los elfos est√°n programando un reloj digital para man\ntenerse en horario con la producci√≥n de regalos. Sin embargo, se han encontrado \ncon un desaf√≠o de programaci√≥n interesante. Necesitan una funci√≥n que, dada una \nhora en formato 'HH:MM', cree una representaci√≥n visual de esta hora en un reloj\n digital devolviendo un array de arrays de caracteres.\nLa pantalla del reloj tiene 7 filas y 17 columnas, y cada d√≠gito de la hora ocup\na 7 filas y 3 columnas. Los d√≠gitos est√°n compuestos por asteriscos (*) y espaci\nos en blanco (). Entre cada d√≠gito hay una columna vac√≠a.\nLos dos puntos para separar horas y minutos se dibujan usando dos aster√≠scos (*)\n y siempre se colocan en la misma posici√≥n, en las filas 2 y 4, en la columna 9,\n respectivamente (nota: la indexaci√≥n de filas y columnas comienza en 0).\nPor ejemplo, si la funci√≥n recibe 01:30 debe devolver:\n\nPara saber c√≥mo dibujar cada d√≠gito, nos han pasado la siguiente imagen. Como ve\ns, cada d√≠gito est√° compuesto por 7 filas y 3 columnas. Los p√≠xeles en rojo, nos\notros lo representaremos con un asterisco (*), y los p√≠xeles en blanco, con un e\nspacio ():\n"
        },
        "code": "drawClock('01:30') // ‚¨áÔ∏è\n\n[\n  ['*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*', '*'],\n  ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n  ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n  ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n  ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n  ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n  ['*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*', '*']\n]\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/18\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/18\n"
        }
    },
    19: {
        "title": {
            "en": "Challenge #19: üí£ Face the sabotage",
            "es": "Reto #19: üí£ Enfrenta el sabotaje"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "Alert at Santa's toy factory! The Grinch üòà has infiltrated the warehouse and sa\nbotaged some of the toys üí£.\nThe elves need help to find the sabotaged toys and remove them before Christmas \ncomes. For this, we have the warehouse map üó∫Ô∏è, which is a matrix.\nThe * represent the sabotaged toys, and empty cells with a blank space  are safe\n places.\nYour task is to write a function that returns the same matrix but, at each posit\nion, shows us the number of sabotaged toys in the adjacent cells.\nIf a cell contains a sabotaged toy, it should remain the same. If a cell does no\nt touch any sabotaged toy, it should contain a blank space .\n\nKeep in mind that‚Ä¶\n\nDiagonal cells are also considered adjacent.\nThe board will always have at least one empty cell  and a sabotaged toy *.\nThe board can be of any size.\nThe numbers are strings.\n",
            "es": "¬°Alerta en la f√°brica de juguetes de Santa! El Grinch üòà se ha infiltrado en el \nalmac√©n y ha saboteado algunos de los juguetes üí£.\nLos elfos necesitan ayuda para encontrar los juguetes saboteados y eliminarlos a\nntes de que llegue la Navidad. Para ello tenemos el mapa üó∫Ô∏è del almac√©n, que es\n una matriz.\nLos * representan los juguetes saboteados y las celdas vac√≠as con un espacio en \nblanco  son los lugares seguros.\nTu tarea es escribir una funci√≥n que devuelva la misma matriz pero, en cada posi\nci√≥n, nos indique el n√∫mero de juguetes saboteados que hay en las celdas adyacen\ntes.\nSi una celda contiene un juguete saboteado, debe permanecer igual. Si una celda \nno toca ning√∫n juguete saboteado, debe contener un espacio en blanco .\n\nTen en cuenta que‚Ä¶\n\nLas celdas diagonales tambi√©n se consideran adyacentes.\nEl tablero siempre tendr√° al menos una celda vac√≠a  y un juguete saboteado *.\nEl tablero puede tener cualquier tama√±o.\nLos n√∫meros son cadenas de texto.\n"
        },
        "code": "const store = [\n  ['*', ' ', ' ', ' '],\n  [' ', ' ', '*', ' '],\n  [' ', ' ', ' ', ' '],\n  ['*', ' ', ' ', ' ']\n]\n\nconsole.log(revealSabotage(board))\n/* Should display:\n[\n    ['*', '2', '1', '1'],\n    ['1', '2', '*', '1'],\n    ['1', '2', '1', '1'],\n    ['*', '1', ' ', ' ']\n]\n*/\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/19\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/19\n"
        }
    },
    20: {
        "title": {
            "en": "Challenge #20: üèãÔ∏è‚Äç‚ôÇÔ∏è Distribute the weight",
            "es": "Reto #20: üèãÔ∏è‚Äç‚ôÇÔ∏è Distribuye el peso"
        },
        "level": {
            "en": "Level: Hard",
            "es": "Nivel: Dif"
        },
        "lvl_code": 2,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "We're having trouble loading the toys onto Santa's üéÖ sleigh üõ∑! It seems like t\nhe toy distribution isn't quite right and the sleigh can't take off. Could you h\nelp us solve this problem?\nTo solve it we've decided to use a method similar to that of an image filter. At\n each position, we're going to distribute the load of the toys based on the numb\ner of toys in the neighboring positions.\nA neighboring position is one that is above, below, to the left, or to the right\n of the current position. Therefore, positions diagonally are not considered nei\nghbors.\nWrite a function distributeGifts that receives a matrix of numbers representing \nthe toys in the sleigh and returns another matrix of the same size and number of\n elements but where each element is the average of its original value and the va\nlues of its neighbors.\nBear in mind that there are positions that are null and that won't count for the\n average as a neighbor but will indeed be replaced by the average value of its n\neighbors.\nFor example, let's look at a complete example:\n\nPlease note:\n\nMatrices are not always square, they can have more rows than columns or vice ver\nsa.\nTo round off the values, you should use the Math.round() function from JavaScrip\nt.\nNull values are not counted for calculating the average but they are replaced by\n the average value of their neighbors.\nThe edges of the matrix have fewer possible neighbors than the rest of the posit\nions.\nThey are always positive integers.\n",
            "es": "¬°Tenemos problemas con la carga de los juguetes en el trineo üõ∑ de Santa üéÖ! Par\nece que la distribuci√≥n de los juguetes no es la adecuada y el trineo no puede d\nespegar. ¬øPodr√≠as ayudarnos a resolver este problema?\nPara solucionarlo hemos decidido utilizar un m√©todo similar al de un filtro de i\nm√°genes. En cada posici√≥n, vamos a distribuir la carga de los juguetes en funci√≥\nn del n√∫mero de juguetes de las posiciones vecinas.\nUna posici√≥n vecina es aquella que est√° encima, abajo, a la izquierda o a la der\necha de la posici√≥n actual. Por lo tanto, no se consideran vecinas las posicione\ns en diagonal.\nEscribe una funci√≥n distributeGifts que reciba una matriz de n√∫meros representan\ndo los juguetes en el trineo y devuelva otra matriz con el mismo tama√±o y n√∫mero\n de elementos pero donde cada elemento es el promedio de su valor original y los\n valores de sus vecinos.\nTen en cuenta que hay posiciones que son null y que no contar√°n para el promedio\n como vecino pero s√≠ se sustituir√° por el valor promedio de sus vecinos.\nPor ejemplo, vamos a ver un ejemplo completo:\n\nTen en cuenta:\n\nLas matrices no siempre son cuadradas, pueden tener m√°s filas que columnas o vic\neversa.\nPara redondear los valores, debes utilizar la funci√≥n Math.round() de JavaScript\n.\nLos valores null no se tienen en cuenta para el c√°lculo del promedio pero s√≠ se \nsustituyen por el valor promedio de sus vecinos.\nLos bordes de la matriz tienen menos vecinos posibles que el resto de posiciones\n.\nSiempre son n√∫meros enteros positivos.\n"
        },
        "code": "const input = [\n  [4, 5, 1],\n  [6, null, 3],\n  [8, null, 4]\n]\n\ndistributeGifts(input)\n\n// Step by step result of the first few calculations:\n\n// At position [0][0] we have the value 4\n// Its neighbors are the values 5 and 6\n// (4 + 5 + 6) / 3 = 5\n\n// At position [0][1] we have the value 5\n// Its neighbors are the values 4 and 1\n// (5 + 4 + 1) / 3 = 3.33\n// Math.round(3.33) = 3\n\n// At position [0][2] we have the value 1\n// Its neighbors are the values 5 and 3\n// (1 + 5 + 3) / 3 = 3\n\n// At position [1][0] we have the value 6\n// Its neighbors are the values 4, 8\n// (6 + 4 + 8 ) / 3 = 6\n\n// At position [1][1] we have the value null\n// Its neighbors are the values 5, 6 and 3\n// (5 + 6 + 3) / 3 = 4.66\n// Math.round(4.66) = 5\n// ... and so on with the rest of the positions\n[\n  [(4 + 5 + 6) / 3, (5 + 4 + 1) / 3, (1 + 5 + 3) / 3],\n  [(6 + 4 + 8) / 3, (5 + 6 + 3) / 3, (3 + 1 + 4) / 3],\n  [(8 + 6) / 2, (8 + 4) / 2, (4 + 3) / 2]\n]\n\n// Final result after rounding with Math.round()\n[\n  [5, 3, 3],\n  [6, 5, 3],\n  [7, 6, 4]\n]\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/20\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/20\n"
        }
    },
    21: {
        "title": {
            "en": "Challenge #21: ü™ê Binary message",
            "es": "Reto #21: ü™ê Mensaje binario"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "The elves are receiving strange binary messages from Mars ü™ê. Are the aliens try\ning to communicate with them? üëΩ\nThe message that arrives is an array of 0s and 1s. It seems they have found a pa\nttern‚Ä¶ To make sure, they want to find the longest segment of the string where t\nhe number of 0s and 1s is equal.\n\nKeep in mind that if there is more than one balanced pattern, you should return \nthe longest and the first one you find from left to right.\nThey say that if they find the pattern, they will be able to send a message back\n to Mars üöÄ. It seems that they have to send it to https://mars.codes.",
            "es": "Los elfos est√°n recibiendo mensajes binarios extra√±os desde Marte ü™ê. ¬øLos extra\nterrestres est√°n tratando de comunicarse con ellos? üëΩ\nEl mensaje que llega es un array de 0s y 1s. Parece que han encontrado un patr√≥n\n‚Ä¶ Para asegurarse, quieren encontrar el segmento m√°s largo de la cadena donde el\n n√∫mero de 0s y 1s sea igual.\n\nTen en cuenta que si hay m√°s de un patr√≥n equilibrado, debes devolver el m√°s lar\ngo y el primero que encuentres de izquierda a derecha.\nDicen que si encuentran el patr√≥n, podr√°n enviar un mensaje de vuelta a Marte üöÄ\n. Parece ser que tienen que enviarlos a https://mars.codes."
        },
        "code": "findBalancedSegment([1, 1, 0, 1, 1, 0, 1, 1])\n//                         |________|\n// position of segment:    [2, 5]\n// longest balanced\n// of 0s and 1s\n\nfindBalancedSegment([1, 1, 0])\n//                      |__|\n//                     [1, 2]\n\nfindBalancedSegment([1, 1, 1])\n// no balanced segments: []\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/21\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/21\n"
        }
    },
    22: {
        "title": {
            "en": "Challenge #22: üöÇ Programming language",
            "es": "Reto #22: üöÇ Lenguaje de programaci√≥n"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In Santa's toy factory, the elves are developing a programming language called S\nanta.js üë®‚Äçüíªüë©‚Äçüíª based on symbols to control their toy machines üöÇ.\nThey have created a simple instruction system and need your help to build a comp\niler that interprets these symbols.\nThe compiler works with a counter that initially has a value of 0. The instructi\nons will modify the value of this counter.\nElves' language instructions based on symbols:\n\n+: Increments the counter value by 1.\n*: Multiplies the counter value by 2.\n-: Subtracts 1 from the counter value.\n%: Mark a return point. Does not modify the counter.\n<: Go back once to the last instruction with the % symbol it has seen. If there \nis no previous %, it does nothing.\n¬ø: Starts a conditional block that executes if the counter is greater than 0.\n?: Ends a conditional block.\n\nCreate a compile function that receives a string with the language instructions \nand returns the result of executing them. Here are some examples:\n",
            "es": "En la f√°brica de juguetes de Santa, los elfos est√°n desarrollando un lenguaje de\n programaci√≥n llamado Santa.js üë®‚Äçüíªüë©‚Äçüíª basado en s√≠mbolos para controlar sus \nm√°quinas de juguetes üöÇ.\nHan creado un sistema de instrucciones simple y necesitan tu ayuda para construi\nr un compilador que interprete estos s√≠mbolos.\nEl compilador trabaja con un contador que inicialmente tiene un valor de 0. Las \ninstrucciones modificar√°n el valor de este contador.\nInstrucciones del lenguaje de los elfos en base a s√≠mbolos:\n\n+: Incrementa en 1 el valor del contador.\n*: Multiplica por 2 el valor del contador.\n-: Resta 1 al valor del contador.\n%: Marca un punto de retorno. No modifica el contador.\n<: Vuelve atr√°s una vez a la √∫ltima instrucci√≥n con el s√≠mbolo % que haya visto.\n Si no hay un % previo, no hace nada.\n¬ø: Inicia un bloque condicional que se ejecuta si el contador es mayor a 0.\n?: Finaliza un bloque condicional.\n\nCrea una funci√≥n compile que reciba un string con las instrucciones del lenguaje\n y devuelve el resultado de ejecutarlas. Aqu√≠ tienes algunos ejemplos:\n"
        },
        "code": "compile('++*-') // 3\n// (1 + 1) * 2 - 1 = 3\n\ncompile('++%++<') // 6\n// 1 + 1 + 1 + 1 + 1 + 1 = 6\n\ncompile('++<--') // 0\n// 1 + 1 - 1 - 1 = 0\n\ncompile('++¬ø+?') // 3\n// 1 + 1 + 1 = 3\n\ncompile('--¬ø+++?') // -2\n// - 1 - 1 = -2\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/22\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/22\n"
        }
    },
    23: {
        "title": {
            "en": "Challenge #23: üçΩÔ∏è Christmas dinner",
            "es": "Reto #23: üçΩÔ∏è La comida de Navidad"
        },
        "level": {
            "en": "Level: Easy",
            "es": "Nivel: F√°cil"
        },
        "lvl_code": 0,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "Santa üéÖ is organizing a big Christmas dinner ü´ì and wants to ensure that all di\nshes are unique and varied!\nHe gives you a list of Christmas dishes where each element consists of a list of\n strings that start with the name of the dish, followed by all the ingredients u\nsed for its preparation.\nYou have to write a function that groups the dishes by ingredients whenever ther\ne are at least 2 dishes that contain them.\nSo we return an array of arrays where the first position is the name of the ingr\nedient and the rest are the names of the dishes.\nBoth the list of ingredients and the dishes should be alphabetically ordered.\n\nKeep in mind that:\n\nAll the names of the dishes are different.\nThe names of the ingredients for a given dish are different from each other.\nIf there are no repeated ingredients, we return an empty array.\n",
            "es": "¬°Santa üéÖ est√° organizando una gran cena navide√±a ü´ì y quiere asegurarse de que \ntodos los platos sean √∫nicos y variados!\nTe da una lista de platos navide√±os donde cada elemento consiste en una lista de\n strings que comienza con el nombre del plato, seguido de todos los ingredientes\n utilizados para su preparaci√≥n.\nTienes que escribir una funci√≥n que agrupe los platos por ingredientes siempre q\nue haya al menos 2 platos que los contengan.\nAs√≠ que devolvemos un array de arrays donde la primera posici√≥n es el nombre del\n ingrediente y el resto los nombres de los platos.\nTanto la lista de ingredientes como los platos deben estar ordenados alfab√©ticam\nente.\n\nTen en cuenta que:\n\nTodos los nombres de los platos son diferentes.\nLos nombres de los ingredientes para un plato dado son distintos entre s√≠.\nSi no hay ingredientes repetidos, devolvemos un array vac√≠o.\n"
        },
        "code": "const dishes = [\n  [\"christmas turkey\", \"turkey\", \"sauce\", \"herbs\"],\n  [\"cake\", \"flour\", \"sugar\", \"egg\"],\n  [\"hot chocolate\", \"chocolate\", \"milk\", \"sugar\"],\n  [\"pizza\", \"sauce\", \"tomato\", \"cheese\", \"ham\"],\n]\n\norganizeChristmasDinner(dishes)\n\n/*\n\n\"sauce\" is in 2 dishes: \"christmas turkey\" and \"pizza\".\n\"sugar\" is in 2 dishes: \"cake\" and \"hot chocolate\".\nThe rest of the ingredients only appear in one dish, so we do not show them.\n\nWe show \"sauce\" first because alphabetically it comes before \"sugar\".\nAnd the dishes of each ingredient are also alphabetically ordered.\n\n[\n  [\"sauce\", \"christmas turkey\", \"pizza\"],\n  [\"sugar\", \"cake\", \"hot chocolate\"]\n]\n*/\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/23\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/23\n"
        }
    },
    24: {
        "title": {
            "en": "Challenge #24: ü™ú Jump on the stairs",
            "es": "Reto #24: ü™ú Brincos en la escalera"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "In the village of Santa, there is a magic staircase that leads to the toy factor\ny üß∏. The elves, always looking to get exercise and have fun üèÉ‚Äç‚ôÇÔ∏è, decide to ju\nmp the steps of the staircase.\nThey give us steps as the number of steps on the staircase and the maximum numbe\nr of steps maxJump that an elf can jump in a single jump.\nYour task is to help the elves find all the possible sequences of jumps they can\n make to go up the staircase, sorted from least to most. Considering that the el\nves can jump at most maxJump steps in a single jump (but they can jump fewer ste\nps if they wish).\nFor example, if there is a staircase of steps = 4 and maxJump = 2 is the maximum\n number of steps that an elf can jump in a single jump, then there are five poss\nible jumping sequences:\n\n[1, 1, 1, 1] (jumps 1 step 4 times)\n[1, 1, 2] (jumps 1 step 2 times and then 2 steps)\n[1, 2, 1] (jumps 1 step, then 2 steps and then 1 step)\n[2, 1, 1] (jumps 2 steps, then 1 step and then 1 step)\n[2, 2] (jumps 2 steps 2 times)\n\nMore examples:\n",
            "es": "En la aldea de Santa, hay una escalera m√°gica que lleva a la f√°brica de juguetes\n üß∏. Los elfos, siempre buscando hacer ejercicio y divertirse üèÉ‚Äç‚ôÇÔ∏è, deciden sal\ntar los pelda√±os de la escalera.\nNos dan steps como el n√∫mero de pelda√±os de la escalera y el n√∫mero m√°ximo de pe\nlda√±os maxJump que un elfo puede saltar en un solo salto.\nTu tarea es ayudar a los elfos a encontrar todas las posibles secuencias de salt\nos que pueden hacer para subir la escalera, ordenadas de menos a m√°s. Teniendo e\nn cuenta que los elfos pueden saltar como m√°ximo maxJump pelda√±os en un solo sal\nto (pero pueden saltar menos pelda√±os si as√≠ lo desean).\nPor ejemplo, si hay una escalera de steps = 4 y maxJump = 2 es el n√∫mero m√°ximo \nde pelda√±os que un elfo puede saltar en un solo salto, entonces hay cinco secuen\ncias de saltos posibles:\n\n[1, 1, 1, 1] (salta 1 pelda√±o 4 veces)\n[1, 1, 2] (salta 1 pelda√±o 2 veces y luego 2 pelda√±os)\n[1, 2, 1] (salta 1 pelda√±o, luego 2 pelda√±os y luego 1 pelda√±o)\n[2, 1, 1] (salta 2 pelda√±os, luego 1 pelda√±o y luego 1 pelda√±o)\n[2, 2] (salta 2 pelda√±os 2 veces)\n\nM√°s ejemplos:\n"
        },
        "code": "getStaircasePaths(2, 1) // [[1, 1]]\ngetStaircasePaths(3, 3) // [[1, 1, 1], [1, 2], [2, 1], [3]]\ngetStaircasePaths(5, 1) // [[1, 1, 1, 1, 1]]\ngetStaircasePaths(5, 2)\n/*\n[\n  [1, 1, 1, 1, 1],\n  [1, 1, 1, 2],\n  [1, 1, 2, 1],\n  [1, 2, 1, 1],\n  [1, 2, 2],\n  [2, 1, 1, 1],\n  [2, 1, 2],\n  [2, 2, 1],\n]\n*/\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/24\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/24\n"
        }
    },
    25: {
        "title": {
            "en": "Challenge #25: üó∫Ô∏è Calculating distances",
            "es": "Reto #25: üó∫Ô∏è Calculando distancias"
        },
        "level": {
            "en": "Level: Medium",
            "es": "Nivel: Medio"
        },
        "lvl_code": 1,
        "dsc_msg": {
            "en": "Instructions",
            "es": "Instrucciones"
        },
        "description": {
            "en": "Santa Claus üéÖ has already delivered all the gifts to the children but they want\n to see if they can improve for next year.\nThe elves want to know how many moves Santa Claus üõ∑ made to deliver all the gif\nts. For this, they give you a map of the city with the location of each child an\nd Santa.\nThe map is a multiline text string where each character represents a square. The\n children are represented by numbers from 1 to 9 and Santa Claus by the letter S\n. The rest of the squares are .\nSanta Claus can only move up, down, left, or right, and each move counts as 1 km\n. In addition, he always starts at the S position and must deliver the gifts in \norder, from 1 to 9.\n\nWrite a travelDistance function that receives a map and returns the total distan\nce Santa Claus has traveled according to the position of the children.\nTake into account that:\n\nThe map doesn't have to be square.\nThe map will always have at least one child.\nThe map will always have an initial position for Santa Claus.\nThe numbers of the kids never repeat.\n",
            "es": "Ya ha entregado Santa Claus üéÖ todos los regalos a los ni√±os pero quieren revisa\nr si pueden mejorar de cara al a√±o que viene.\nLos elfos quieren saber cu√°ntos movimientos ha hecho Santa Claus üõ∑ para entrega\nr todos los regalos. Para ello, te dan un mapa de la ciudad con la ubicaci√≥n de \ncada ni√±o y de Santa.\nEl mapa es una cadena de texto multi l√≠nea donde cada caracter representa una ca\nsilla. Los ni√±os se representan por n√∫meros del 1 al 9 y Santa Claus por la letr\na S. El resto de casillas son .\nSanta Claus s√≥lo puede moverse hacia arriba, abajo, izquierda o derecha, y cada \nmovimiento cuenta como 1 km. Adem√°s, siempre empieza en la posici√≥n S y debe ent\nregar los regalos en orden, del 1 al 9.\n\nEscribe una funci√≥n travelDistance que reciba un mapa y devuelva la distancia to\ntal que ha recorrido Santa Claus seg√∫n la posici√≥n de los ni√±os.\nTen en cuenta que:\n\nEl mapa no tiene por qu√© ser cuadrado.\nEl mapa siempre tendr√° al menos un ni√±o.\nEl mapa siempre tendr√° una posici√≥n inicial para Santa Claus.\nLos n√∫meros de los ni√±os nunca se repiten.\n"
        },
        "code": "const map = `.....1....\n..S.......\n..........\n....3.....\n......2...`\n\nconst result = travelDistance(map)\nconsole.log(result) // -> 12 km\n/*\nFrom S to kid 1: 4 moves\nFrom kid 1 to 2: 5 moves\nFrom kid 2 to 3: 3 moves\nTotal: 12 moves\n*/\n\nconst result2 = travelDistance(`..S.1...`)\nconsole.log(result2) // -> 2\n",
        "ref": {
            "en": "\nReference: https://adventjs.dev/challenges/2023/25\n",
            "es": "\nReferencia: https://adventjs.dev/es/challenges/2023/25\n"
        }
    }
}

export const TEMPLATES: Record<number, Record<'js' | 'ts', string>> = {
    1: {
        "js": "export function findFirstRepeated(gifts) {\n    // Code here\n    return 0\n}\n",
        "ts": "export function findFirstRepeated(gifts: number[]) {\n    // Code here\n    return 0\n}\n",
    },
    2: {
        "js": "export function manufacture(gifts, materials) {\n    // Code here\n    return []\n}\n",
        "ts": "export function manufacture(gifts: string[], materials: string) {\n    // Code here\n    return []\n}\n",
    },
    3: {
        "js": "export function findNaughtyStep(original, modified) {\n    // Code here\n    return ''\n}\n",
        "ts": "export function findNaughtyStep(original: string, modified: string) {\n    // Code here\n    return ''\n}\n",
    },
    4: {
        "js": "export function decode(message) {\n    // Code here\n    return ''\n}\n",
        "ts": "export function decode(message: string) {\n    // Code here\n    return ''\n}\n",
    },
    5: {
        "js": "export function cyberReindeer(road, time) {\n    // Code here\n    return []\n}\n",
        "ts": "export function cyberReindeer(road: string, time: number) {\n    // Code here\n    return []\n}\n",
    },
    6: {
        "js": "export function maxDistance(movements) {\n    // Code here\n    return 0\n}\n",
        "ts": "export function maxDistance(movements: string) {\n    // Code here\n    return 0\n}\n",
    },
    7: {
        "js": "export function drawGift(size, symbol) {\n    // Code here\n    return ''\n}\n",
        "ts": "export function drawGift(size: number, symbol: string) {\n    // Code here\n    return ''\n}\n",
    },
    8: {
        "js": "export function organizeGifts(gifts) {\n    // Code here\n    return ''\n}\n",
        "ts": "export function organizeGifts(gifts: string) {\n    // Code here\n    return ''\n}\n",
    },
    9: {
        "js": "export function adjustLights(lights) {\n    // Code here\n    return 0\n}\n",
        "ts": "export function adjustLights(lights: string[]) {\n    // Code here\n    return 0\n}\n",
    },
    10: {
        "js": "export function createChristmasTree(ornaments, height) {\n    return '|'\n}\n",
        "ts": "export function createChristmasTree(ornaments: string, height: number) {\n    return '|'\n}\n",
    },
    11: {
        "js": "export function getIndexsForPalindrome(word) {\n    return [0, 0]\n}\n",
        "ts": "export function getIndexsForPalindrome(word: string) {\n    return [0, 0]\n}\n",
    },
    12: {
        "js": "export function checkIsValidCopy(original, copy) {\n    return true\n}\n",
        "ts": "export function checkIsValidCopy(original: string, copy: string) {\n    return true\n}\n",
    },
    13: {
        "js": "export function calculateTime(deliveries) {\n    return '00:00:00'\n}\n",
        "ts": "export function calculateTime(deliveries: string[]) {\n    return '00:00:00'\n}\n",
    },
    14: {
        "js": "export function maxGifts(houses) {\n    return 0\n}\n",
        "ts": "export function maxGifts(houses: number[]) {\n    return 0\n}\n",
    },
    15: {
        "js": "export function autonomousDrive(store, movements) {\n    return store\n}\n",
        "ts": "export function autonomousDrive(store: string[], movements: string[]) {\n    return store\n}\n",
    },
    16: {
        "js": "export function transformTree(tree) {\n    return tree\n}\n",
        "ts": "export interface ANSWER_TYPE {\n    value: number\n    left: ANSWER_TYPE | null\n    right: ANSWER_TYPE | null\n}\n\nexport function transformTree(tree: Array<number | null>): ANSWER_TYPE | null {\n    return null\n}\n",
    },
    17: {
        "js": "export function optimizeIntervals(intervals) {\n    return intervals\n}\n",
        "ts": "export function optimizeIntervals(intervals: Array<[number, number]>): Array<[number, number]> {\n    return intervals\n}\n",
    },
    18: {
        "js": "export function drawClock(time) {\n    return []\n}\n",
        "ts": "export function drawClock(time: string) {\n    return []\n}\n",
    },
    19: {
        "js": "export function revealSabotage(store) {\n    return []\n}\n",
        "ts": "export function revealSabotage(store: string[][]) {\n    return []\n}\n",
    },
    20: {
        "js": "export function distributeGifts(weights) {\n    return weights\n}\n",
        "ts": "export function distributeGifts(weights: Array<Array<number | null>>): number[][] {\n    return weights\n}\n",
    },
    21: {
        "js": "export function findBalancedSegment(message) {\n    return []\n}\n",
        "ts": "export function findBalancedSegment(message: number[]) {\n    return []\n}\n",
    },
    22: {
        "js": "export function compile(code) {\n    return 0\n}\n",
        "ts": "export function compile(code: string) {\n    return 0\n}\n",
    },
    23: {
        "js": "export function organizeChristmasDinner(dishes) {\n    return []\n}\n",
        "ts": "export function organizeChristmasDinner(dishes: Array<string[]>) {\n    return []\n}\n",
    },
    24: {
        "js": "export function getStaircasePaths(steps, maxJump) {\n    return []\n}\n",
        "ts": "export function getStaircasePaths(steps: number, maxJump: number) {\n    return []\n}\n",
    },
    25: {
        "js": "export function travelDistance(map) {\n    return 0\n}\n",
        "ts": "export function travelDistance(map: string) {\n    return 0\n}\n",
    }
}

export const TESTS: Record<number, Record<'ts' | 'js', string>> = {
    1: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { findFirstRepeated } from '../in/1.ts'\n\nDeno.test(\"Test #01\", () => {\n    assertInstanceOf(findFirstRepeated, Function);\n})\n\nDeno.test(\"Test #02\", () => {\n    assertEquals(findFirstRepeated([2, 1, 3, 5, 3, 2]), 3);\n})\n\nDeno.test(\"Test #03\", () => {\n    assertEquals(findFirstRepeated([2, 2]), 2);\n})\n\nDeno.test(\"Test #04\", () => {\n    assertEquals(findFirstRepeated([2, 4, 3, 5, 1]), -1);\n})\n\nDeno.test(\"Test #05\", () => {\n    assertEquals(findFirstRepeated([1, 3, 4, 5, 0, 1, 3, 0, 7]), 1);\n})\n\nDeno.test(\"Test #06\", () => {\n    assertEquals(findFirstRepeated([]), -1);\n})\n\nDeno.test(\"Test #07\", () => {\n    assertEquals(findFirstRepeated([10, 20, 30]), -1);\n})\n\nDeno.test(\"Test #08\", () => {\n    assertEquals(findFirstRepeated([5, 1, 2, 3, 2, 5, 1]), 2);\n})\n\nDeno.test(\"Test #09\", () => {\n    assertEquals(findFirstRepeated([1, 10, 2, 10, 20, 50, 7, 0, 0, 7]), 10);\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { findFirstRepeated } from '../in/1.js'\n\nDeno.test(\"Test #01\", () => {\n    assertInstanceOf(findFirstRepeated, Function);\n})\n\nDeno.test(\"Test #02\", () => {\n    assertEquals(findFirstRepeated([2, 1, 3, 5, 3, 2]), 3);\n})\n\nDeno.test(\"Test #03\", () => {\n    assertEquals(findFirstRepeated([2, 2]), 2);\n})\n\nDeno.test(\"Test #04\", () => {\n    assertEquals(findFirstRepeated([2, 4, 3, 5, 1]), -1);\n})\n\nDeno.test(\"Test #05\", () => {\n    assertEquals(findFirstRepeated([1, 3, 4, 5, 0, 1, 3, 0, 7]), 1);\n})\n\nDeno.test(\"Test #06\", () => {\n    assertEquals(findFirstRepeated([]), -1);\n})\n\nDeno.test(\"Test #07\", () => {\n    assertEquals(findFirstRepeated([10, 20, 30]), -1);\n})\n\nDeno.test(\"Test #08\", () => {\n    assertEquals(findFirstRepeated([5, 1, 2, 3, 2, 5, 1]), 2);\n})\n\nDeno.test(\"Test #09\", () => {\n    assertEquals(findFirstRepeated([1, 10, 2, 10, 20, 50, 7, 0, 0, 7]), 10);\n})\n"
    },
    2: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { manufacture } from '../in/2.ts'\n\nDeno.test(\"Test #01\", () => {\n    assertInstanceOf(manufacture, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(manufacture(['tren', 'oso', 'pelota'], 'tronesa'), ['tren', 'oso'])\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(manufacture(['coche', 'mu√±eca', 'balon'], 'ocmu√±alb'), [])\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(manufacture(['patineta', 'robot', 'libro'], 'nopor'), [])\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(manufacture([], 'letras'), [])\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { manufacture } from '../in/2.js'\n\nDeno.test(\"Test #01\", () => {\n    assertInstanceOf(manufacture, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(manufacture(['tren', 'oso', 'pelota'], 'tronesa'), ['tren', 'oso'])\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(manufacture(['coche', 'mu√±eca', 'balon'], 'ocmu√±alb'), [])\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(manufacture(['patineta', 'robot', 'libro'], 'nopor'), [])\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(manufacture([], 'letras'), [])\n})\n"
    },
    3: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { findNaughtyStep } from '../in/3.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(findNaughtyStep, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(findNaughtyStep('abcd', 'abcde'), 'e')\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(findNaughtyStep('abcde', 'abcd'), 'e')\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(findNaughtyStep('xxxx', 'xxoxx'), 'o')\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(findNaughtyStep('stepfor', 'stepor'), 'f')\n})\n\nDeno.test('Test #06', () => {\n    assertEquals(findNaughtyStep('iiiii', 'iiiii'), '')\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { findNaughtyStep } from '../in/3.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(findNaughtyStep, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(findNaughtyStep('abcd', 'abcde'), 'e')\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(findNaughtyStep('abcde', 'abcd'), 'e')\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(findNaughtyStep('xxxx', 'xxoxx'), 'o')\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(findNaughtyStep('stepfor', 'stepor'), 'f')\n})\n\nDeno.test('Test #06', () => {\n    assertEquals(findNaughtyStep('iiiii', 'iiiii'), '')\n})\n"
    },
    4: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { decode } from '../in/4.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(decode, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(decode('hola (odnum)'), 'hola mundo')\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(decode('(olleh) (dlrow)!'), 'hello world!')\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(decode('sa(u(cla)atn)s'), 'santaclaus')\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(decode('((nta)(sa))'), 'santa')\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { decode } from '../in/4.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(decode, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(decode('hola (odnum)'), 'hola mundo')\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(decode('(olleh) (dlrow)!'), 'hello world!')\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(decode('sa(u(cla)atn)s'), 'santaclaus')\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(decode('((nta)(sa))'), 'santa')\n})\n"
    },
    5: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { cyberReindeer } from '../in/5.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(cyberReindeer, Function);\n})\n\nDeno.test('Test #02', () => {\n    const expected = [\n        'S..|...|..',\n        '.S.|...|..',\n        '..S|...|..',\n        '..S|...|..',\n        '..S|...|..',\n        '...S...*..',\n        '...*S..*..',\n        '...*.S.*..',\n        '...*..S*..',\n        '...*...S..'\n    ]\n    assertEquals(cyberReindeer('S..|...|..', 10), expected)\n})\n\nDeno.test('Test #03', () => {\n    const expected = [\n        'S.|.',\n        '.S|.',\n        '.S|.',\n        '.S|.'\n    ]\n    assertEquals(cyberReindeer('S.|.', 4), expected)\n})\n\nDeno.test('Test #04', () => {\n    const expected = [\n        'S.|.|.',\n        '.S|.|.',\n        '.S|.|.',\n        '.S|.|.',\n        '.S|.|.',\n        '..S.*.',\n        '..*S*.'\n    ]\n    assertEquals(cyberReindeer('S.|.|.', 7), expected)\n})\n\nDeno.test('Test #05', () => {\n    const expected = [\n        'S.|..',\n        '.S|..',\n        '.S|..',\n        '.S|..',\n        '.S|..',\n        '..S..'\n    ]\n    assertEquals(cyberReindeer('S.|..', 6), expected)\n})\n\nDeno.test('Test #06', () => {\n    const expected = [\n        'S.|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '..S.*.*......*.**.........',\n        '..*S*.*......*.**.........',\n        '..*.S.*......*.**.........'\n    ]\n    assertEquals(cyberReindeer('S.|.|.|......|.||.........', 8), expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { cyberReindeer } from '../in/5.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(cyberReindeer, Function);\n})\n\nDeno.test('Test #02', () => {\n    const expected = [\n        'S..|...|..',\n        '.S.|...|..',\n        '..S|...|..',\n        '..S|...|..',\n        '..S|...|..',\n        '...S...*..',\n        '...*S..*..',\n        '...*.S.*..',\n        '...*..S*..',\n        '...*...S..'\n    ]\n    assertEquals(cyberReindeer('S..|...|..', 10), expected)\n})\n\nDeno.test('Test #03', () => {\n    const expected = [\n        'S.|.',\n        '.S|.',\n        '.S|.',\n        '.S|.'\n    ]\n    assertEquals(cyberReindeer('S.|.', 4), expected)\n})\n\nDeno.test('Test #04', () => {\n    const expected = [\n        'S.|.|.',\n        '.S|.|.',\n        '.S|.|.',\n        '.S|.|.',\n        '.S|.|.',\n        '..S.*.',\n        '..*S*.'\n    ]\n    assertEquals(cyberReindeer('S.|.|.', 7), expected)\n})\n\nDeno.test('Test #05', () => {\n    const expected = [\n        'S.|..',\n        '.S|..',\n        '.S|..',\n        '.S|..',\n        '.S|..',\n        '..S..'\n    ]\n    assertEquals(cyberReindeer('S.|..', 6), expected)\n})\n\nDeno.test('Test #06', () => {\n    const expected = [\n        'S.|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '.S|.|.|......|.||.........',\n        '..S.*.*......*.**.........',\n        '..*S*.*......*.**.........',\n        '..*.S.*......*.**.........'\n    ]\n    assertEquals(cyberReindeer('S.|.|.|......|.||.........', 8), expected)\n})\n"
    },
    6: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { maxDistance } from '../in/6.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(maxDistance, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(maxDistance('>>*<'), 2)\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(maxDistance('<<<<<'), 5)\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(maxDistance('>***>'), 5)\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(maxDistance('**********'), 10)\n})\n\nDeno.test('Test #06', () => {\n    assertEquals(maxDistance('<<**>>'), 2)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { maxDistance } from '../in/6.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(maxDistance, Function);\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(maxDistance('>>*<'), 2)\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(maxDistance('<<<<<'), 5)\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(maxDistance('>***>'), 5)\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(maxDistance('**********'), 10)\n})\n\nDeno.test('Test #06', () => {\n    assertEquals(maxDistance('<<**>>'), 2)\n})\n"
    },
    7: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { drawGift } from '../in/7.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(drawGift, Function);\n})\n\n// Test: drawGift(4, \"+\")\nDeno.test('Test #02', () => {\n    const expected = `   ####\n  #++##\n #++#+#\n####++#\n#++#+#\n#++##\n####\n`\n    assertEquals(drawGift(4, '+'), expected)\n})\n\nDeno.test('Test #03', () => {\n    const expected = `    #####\n   #***##\n  #***#*#\n #***#**#\n#####***#\n#***#**#\n#***#*#\n#***##\n#####\n`\n    assertEquals(drawGift(5, '*'), expected)\n})\n\n// Test: drawGift(1, \"^\")\nDeno.test('Test #04', () => {\n    const expected = '#\\n'\n    assertEquals(drawGift(1, '^'), expected)\n})\n\n// Test: drawGift(2, \"&\")\nDeno.test('Test #05', () => {\n    const expected = ` ##\n###\n##\n`\n    assertEquals(drawGift(2, '&'), expected)\n})\n\n// Test: drawGift(10, \"%\")\nDeno.test('Test #06', () => {\n    const expected = `         ##########\n        #%%%%%%%%##\n       #%%%%%%%%#%#\n      #%%%%%%%%#%%#\n     #%%%%%%%%#%%%#\n    #%%%%%%%%#%%%%#\n   #%%%%%%%%#%%%%%#\n  #%%%%%%%%#%%%%%%#\n #%%%%%%%%#%%%%%%%#\n##########%%%%%%%%#\n#%%%%%%%%#%%%%%%%#\n#%%%%%%%%#%%%%%%#\n#%%%%%%%%#%%%%%#\n#%%%%%%%%#%%%%#\n#%%%%%%%%#%%%#\n#%%%%%%%%#%%#\n#%%%%%%%%#%#\n#%%%%%%%%##\n##########\n`\n    assertEquals(drawGift(10, '%'), expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { drawGift } from '../in/7.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(drawGift, Function);\n})\n\n// Test: drawGift(4, \"+\")\nDeno.test('Test #02', () => {\n    const expected = `   ####\n  #++##\n #++#+#\n####++#\n#++#+#\n#++##\n####\n`\n    assertEquals(drawGift(4, '+'), expected)\n})\n\nDeno.test('Test #03', () => {\n    const expected = `    #####\n   #***##\n  #***#*#\n #***#**#\n#####***#\n#***#**#\n#***#*#\n#***##\n#####\n`\n    assertEquals(drawGift(5, '*'), expected)\n})\n\n// Test: drawGift(1, \"^\")\nDeno.test('Test #04', () => {\n    const expected = '#\\n'\n    assertEquals(drawGift(1, '^'), expected)\n})\n\n// Test: drawGift(2, \"&\")\nDeno.test('Test #05', () => {\n    const expected = ` ##\n###\n##\n`\n    assertEquals(drawGift(2, '&'), expected)\n})\n\n// Test: drawGift(10, \"%\")\nDeno.test('Test #06', () => {\n    const expected = `         ##########\n        #%%%%%%%%##\n       #%%%%%%%%#%#\n      #%%%%%%%%#%%#\n     #%%%%%%%%#%%%#\n    #%%%%%%%%#%%%%#\n   #%%%%%%%%#%%%%%#\n  #%%%%%%%%#%%%%%%#\n #%%%%%%%%#%%%%%%%#\n##########%%%%%%%%#\n#%%%%%%%%#%%%%%%%#\n#%%%%%%%%#%%%%%%#\n#%%%%%%%%#%%%%%#\n#%%%%%%%%#%%%%#\n#%%%%%%%%#%%%#\n#%%%%%%%%#%%#\n#%%%%%%%%#%#\n#%%%%%%%%##\n##########\n`\n    assertEquals(drawGift(10, '%'), expected)\n})\n"
    },
    8: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { organizeGifts } from '../in/8.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(organizeGifts, Function);\n})\n\n// Test: organizeGifts(\"76a11b\")\n// Expected: \"[a]{a}{a}(aaaaaa){b}(b)\"\nDeno.test('Test #02', () => {\n    assertEquals(organizeGifts('76a11b'), '[a]{a}{a}(aaaaaa){b}(b)')\n})\n\n//   Test: organizeGifts(\"20a\")\n// Expected:\n// \"{a}{a}\"\nDeno.test('Test #03', () => {\n    assertEquals(organizeGifts('20a'), '{a}{a}')\n})\n\n// Test: organizeGifts(\"70b120a4c\")\n\n// Expected:\n// \"[b]{b}{b}[a][a]{a}{a}(cccc)\"\nDeno.test('Test #04', () => {\n    assertEquals(organizeGifts('70b120a4c'), '[b]{b}{b}[a][a]{a}{a}(cccc)')\n})\n\n// Test: organizeGifts(\"9c\")\n\n// Expected:\n// \"(ccccccccc)\"\nDeno.test('Test #05', () => {\n    assertEquals(organizeGifts('9c'), '(ccccccccc)')\n})\n\n// Test: organizeGifts(\"19d51e\")\n\n// Expected:\n// \"{d}(ddddddddd)[e](e)\"\nDeno.test('Test #06', () => {\n    assertEquals(organizeGifts('19d51e'), '{d}(ddddddddd)[e](e)')\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { organizeGifts } from '../in/8.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(organizeGifts, Function);\n})\n\n// Test: organizeGifts(\"76a11b\")\n// Expected: \"[a]{a}{a}(aaaaaa){b}(b)\"\nDeno.test('Test #02', () => {\n    assertEquals(organizeGifts('76a11b'), '[a]{a}{a}(aaaaaa){b}(b)')\n})\n\n//   Test: organizeGifts(\"20a\")\n// Expected:\n// \"{a}{a}\"\nDeno.test('Test #03', () => {\n    assertEquals(organizeGifts('20a'), '{a}{a}')\n})\n\n// Test: organizeGifts(\"70b120a4c\")\n\n// Expected:\n// \"[b]{b}{b}[a][a]{a}{a}(cccc)\"\nDeno.test('Test #04', () => {\n    assertEquals(organizeGifts('70b120a4c'), '[b]{b}{b}[a][a]{a}{a}(cccc)')\n})\n\n// Test: organizeGifts(\"9c\")\n\n// Expected:\n// \"(ccccccccc)\"\nDeno.test('Test #05', () => {\n    assertEquals(organizeGifts('9c'), '(ccccccccc)')\n})\n\n// Test: organizeGifts(\"19d51e\")\n\n// Expected:\n// \"{d}(ddddddddd)[e](e)\"\nDeno.test('Test #06', () => {\n    assertEquals(organizeGifts('19d51e'), '{d}(ddddddddd)[e](e)')\n})\n"
    },
    9: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { adjustLights } from '../in/9.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(adjustLights, Function)\n})\n\n// Test: adjustLights([\"üü¢\", \"üî¥\", \"üü¢\", \"üü¢\", \"üü¢\"]) -> 1\nDeno.test('Test #02', () => {\n    assertEquals(adjustLights(['üü¢', 'üî¥', 'üü¢', 'üü¢', 'üü¢']), 1)\n})\n\n// Test: adjustLights([\"üî¥\", \"üî¥\", \"üü¢\", \"üü¢\", \"üî¥\"]) -> 2\nDeno.test('Test #03', () => {\n    assertEquals(adjustLights(['üî¥', 'üî¥', 'üü¢', 'üü¢', 'üî¥']), 2)\n})\n\n// Test: adjustLights([\"üü¢\", \"üî¥\", \"üü¢\", \"üî¥\", \"üü¢\"]) -> 0\nDeno.test('Test #04', () => {\n    assertEquals(adjustLights(['üü¢', 'üî¥', 'üü¢', 'üî¥', 'üü¢']), 0)\n})\n\n// Test: adjustLights([\"üî¥\", \"üî¥\", \"üî¥\"] -> 1\nDeno.test('Test #05', () => {\n    assertEquals(adjustLights(['üî¥', 'üî¥', 'üî¥']), 1)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { adjustLights } from '../in/9.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(adjustLights, Function)\n})\n\n// Test: adjustLights([\"üü¢\", \"üî¥\", \"üü¢\", \"üü¢\", \"üü¢\"]) -> 1\nDeno.test('Test #02', () => {\n    assertEquals(adjustLights(['üü¢', 'üî¥', 'üü¢', 'üü¢', 'üü¢']), 1)\n})\n\n// Test: adjustLights([\"üî¥\", \"üî¥\", \"üü¢\", \"üü¢\", \"üî¥\"]) -> 2\nDeno.test('Test #03', () => {\n    assertEquals(adjustLights(['üî¥', 'üî¥', 'üü¢', 'üü¢', 'üî¥']), 2)\n})\n\n// Test: adjustLights([\"üü¢\", \"üî¥\", \"üü¢\", \"üî¥\", \"üü¢\"]) -> 0\nDeno.test('Test #04', () => {\n    assertEquals(adjustLights(['üü¢', 'üî¥', 'üü¢', 'üî¥', 'üü¢']), 0)\n})\n\n// Test: adjustLights([\"üî¥\", \"üî¥\", \"üî¥\"] -> 1\nDeno.test('Test #05', () => {\n    assertEquals(adjustLights(['üî¥', 'üî¥', 'üî¥']), 1)\n})\n"
    },
    10: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { createChristmasTree } from '../in/10.ts'\n\nDeno.test('Test #01', () => {\n  assertInstanceOf(createChristmasTree, Function)\n})\n\nDeno.test('Test #02', () => {\n  const expected = `  x\n x x\nx x x\n  |\n`\n  const received = createChristmasTree('x', 3)\n  assertEquals(received, expected)\n})\n\nDeno.test('Test #03', () => {\n  const expected = `   x\n  o x\n o x o\nx o x o\n   |\n`\n  assertEquals(createChristmasTree('xo', 4), expected)\n})\n\nDeno.test('Test #04', function () {\n  const expected = `    1\n   2 3\n  1 2 3\n 1 2 3 1\n2 3 1 2 3\n    |\n`\n  const received = createChristmasTree('123', 5)\n  assertEquals(received, expected)\n})\n\nDeno.test('Test #05', function () {\n  const expected = `  *\n @ o\n* @ o\n  |\n`\n  assertEquals(createChristmasTree('*@o', 3), expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { createChristmasTree } from '../in/10.js'\n\nDeno.test('Test #01', () => {\n  assertInstanceOf(createChristmasTree, Function)\n})\n\nDeno.test('Test #02', () => {\n  const expected = `  x\n x x\nx x x\n  |\n`\n  const received = createChristmasTree('x', 3)\n  assertEquals(received, expected)\n})\n\nDeno.test('Test #03', () => {\n  const expected = `   x\n  o x\n o x o\nx o x o\n   |\n`\n  assertEquals(createChristmasTree('xo', 4), expected)\n})\n\nDeno.test('Test #04', function () {\n  const expected = `    1\n   2 3\n  1 2 3\n 1 2 3 1\n2 3 1 2 3\n    |\n`\n  const received = createChristmasTree('123', 5)\n  assertEquals(received, expected)\n})\n\nDeno.test('Test #05', function () {\n  const expected = `  *\n @ o\n* @ o\n  |\n`\n  assertEquals(createChristmasTree('*@o', 3), expected)\n})\n"
    },
    11: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { getIndexsForPalindrome } from '../in/11.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(getIndexsForPalindrome, Function)\n})\n\n// Test: getIndexsForPalindrome('anna')\nDeno.test('Test #02', () => {\n    assertEquals(getIndexsForPalindrome('anna'), [])\n})\n\n// Test: getIndexsForPalindrome('abab')\nDeno.test('Test #03', () => {\n    assertEquals(getIndexsForPalindrome('abab'), [0, 1])\n})\n\n// Test: getIndexsForPalindrome('abac')\nDeno.test('Test #04', () => {\n    assertEquals(getIndexsForPalindrome('abac'), null)\n})\n\n// Test: getIndexsForPalindrome('aaaaaaaa')\nDeno.test('Test #05', () => {\n    assertEquals(getIndexsForPalindrome('aaaaaaaa'), [])\n})\n\n// Test: getIndexsForPalindrome('aaababa')\nDeno.test('Test #06', () => {\n    assertEquals(getIndexsForPalindrome('aaababa'), [1, 3])\n})\n\n// Test: getIndexsForPalindrome('caababa')\nDeno.test('Test #07', () => {\n    assertEquals(getIndexsForPalindrome('caababa'), null)\n})\n\n// Test: getIndexsForPalindrome('rotavator')\nDeno.test('Test #08', () => {\n    assertEquals(getIndexsForPalindrome('rotavator'), [])\n})\n\n// Test: getIndexsForPalindrome('rotaratov')\nDeno.test('Test #09', () => {\n    assertEquals(getIndexsForPalindrome('rotaratov'), [4, 8])\n})\n\n// Test: getIndexsForPalindrome('saippuakivikauppias')\nDeno.test('Test #10', () => {\n    assertEquals(getIndexsForPalindrome('saippuakivikauppias'), [])\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { getIndexsForPalindrome } from '../in/11.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(getIndexsForPalindrome, Function)\n})\n\n// Test: getIndexsForPalindrome('anna')\nDeno.test('Test #02', () => {\n    assertEquals(getIndexsForPalindrome('anna'), [])\n})\n\n// Test: getIndexsForPalindrome('abab')\nDeno.test('Test #03', () => {\n    assertEquals(getIndexsForPalindrome('abab'), [0, 1])\n})\n\n// Test: getIndexsForPalindrome('abac')\nDeno.test('Test #04', () => {\n    assertEquals(getIndexsForPalindrome('abac'), null)\n})\n\n// Test: getIndexsForPalindrome('aaaaaaaa')\nDeno.test('Test #05', () => {\n    assertEquals(getIndexsForPalindrome('aaaaaaaa'), [])\n})\n\n// Test: getIndexsForPalindrome('aaababa')\nDeno.test('Test #06', () => {\n    assertEquals(getIndexsForPalindrome('aaababa'), [1, 3])\n})\n\n// Test: getIndexsForPalindrome('caababa')\nDeno.test('Test #07', () => {\n    assertEquals(getIndexsForPalindrome('caababa'), null)\n})\n\n// Test: getIndexsForPalindrome('rotavator')\nDeno.test('Test #08', () => {\n    assertEquals(getIndexsForPalindrome('rotavator'), [])\n})\n\n// Test: getIndexsForPalindrome('rotaratov')\nDeno.test('Test #09', () => {\n    assertEquals(getIndexsForPalindrome('rotaratov'), [4, 8])\n})\n\n// Test: getIndexsForPalindrome('saippuakivikauppias')\nDeno.test('Test #10', () => {\n    assertEquals(getIndexsForPalindrome('saippuakivikauppias'), [])\n})\n"
    },
    12: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { checkIsValidCopy } from '../in/12.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(checkIsValidCopy, Function)\n})\n\nDeno.test('Test #02', () => {\n    const received = checkIsValidCopy('Santa Claus is coming', 'sa#ta cl#us is comin#')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #03', () => {\n    const received = checkIsValidCopy('Santa Claus is coming', 'p#nt: cla#s #s c+min#')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #04', () => {\n    const received = checkIsValidCopy('Santa Claus', ' Santa Claus ')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #05', () => {\n    const received = checkIsValidCopy('Santa Claus', '###:. c:+##')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #06', () => {\n    const received = checkIsValidCopy('Santa Claus', 'sant##claus+')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #07', () => {\n    const received = checkIsValidCopy('Santa Claus', 's#+:. c:. s')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #08', () => {\n    const received = checkIsValidCopy('Santa Claus', 's#+:.#c:. s')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #09', () => {\n    const received = checkIsValidCopy('Santa Claus', 'SantA ClauS')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #10', () => {\n    const received = checkIsValidCopy('3 #egalos', '3 .+:# #:')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #11', () => {\n    const received = checkIsValidCopy('3 regalos', '3        ')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #12', () => {\n    const received = checkIsValidCopy('3 regalos 3', '3 .+:# #: 3')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #13', () => {\n    const received = checkIsValidCopy('Santa Claus viene a buscarte para darte muchos regalos y eso es espectacular porque da mucha felicidad a todos los ni√±os', 'Santa Claus viene a buscarte para darte muchos regalos y eso es espectacular porque da mucha felicidad a todos los ni√±o')\n    assertEquals(received, false)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { checkIsValidCopy } from '../in/12.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(checkIsValidCopy, Function)\n})\n\nDeno.test('Test #02', () => {\n    const received = checkIsValidCopy('Santa Claus is coming', 'sa#ta cl#us is comin#')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #03', () => {\n    const received = checkIsValidCopy('Santa Claus is coming', 'p#nt: cla#s #s c+min#')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #04', () => {\n    const received = checkIsValidCopy('Santa Claus', ' Santa Claus ')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #05', () => {\n    const received = checkIsValidCopy('Santa Claus', '###:. c:+##')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #06', () => {\n    const received = checkIsValidCopy('Santa Claus', 'sant##claus+')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #07', () => {\n    const received = checkIsValidCopy('Santa Claus', 's#+:. c:. s')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #08', () => {\n    const received = checkIsValidCopy('Santa Claus', 's#+:.#c:. s')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #09', () => {\n    const received = checkIsValidCopy('Santa Claus', 'SantA ClauS')\n    assertEquals(received, false)\n})\n\nDeno.test('Test #10', () => {\n    const received = checkIsValidCopy('3 #egalos', '3 .+:# #:')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #11', () => {\n    const received = checkIsValidCopy('3 regalos', '3        ')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #12', () => {\n    const received = checkIsValidCopy('3 regalos 3', '3 .+:# #: 3')\n    assertEquals(received, true)\n})\n\nDeno.test('Test #13', () => {\n    const received = checkIsValidCopy('Santa Claus viene a buscarte para darte muchos regalos y eso es espectacular porque da mucha felicidad a todos los ni√±os', 'Santa Claus viene a buscarte para darte muchos regalos y eso es espectacular porque da mucha felicidad a todos los ni√±o')\n    assertEquals(received, false)\n})\n"
    },
    13: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { calculateTime } from '../in/13.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(calculateTime, Function);\n})\n\nDeno.test('Test #02', () => {\n    const expected = '-02:20:00'\n    const received = calculateTime(['00:10:00', '01:00:00', '03:30:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #03', () => {\n    const expected = '-00:30:00'\n    const received = calculateTime(['01:00:00', '05:00:00', '00:30:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #04', () => {\n    const expected = '00:30:00'\n    const received = calculateTime(['02:00:00', '05:00:00', '00:30:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #05', () => {\n    const expected = '-05:29:00'\n    const received = calculateTime(['00:45:00', '00:45:00', '00:00:30', '00:00:30'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #06', () => {\n    const expected = '00:00:00'\n    const received = calculateTime(['02:00:00', '03:00:00', '02:00:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #07', () => {\n    const expected = '05:02:01'\n    const received = calculateTime(['01:01:01', '09:59:59', '01:01:01'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #08', () => {\n    const expected = '-00:00:01'\n    const received = calculateTime(['01:01:01', '03:59:59', '01:01:01', '00:57:58'])\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { calculateTime } from '../in/13.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(calculateTime, Function);\n})\n\nDeno.test('Test #02', () => {\n    const expected = '-02:20:00'\n    const received = calculateTime(['00:10:00', '01:00:00', '03:30:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #03', () => {\n    const expected = '-00:30:00'\n    const received = calculateTime(['01:00:00', '05:00:00', '00:30:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #04', () => {\n    const expected = '00:30:00'\n    const received = calculateTime(['02:00:00', '05:00:00', '00:30:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #05', () => {\n    const expected = '-05:29:00'\n    const received = calculateTime(['00:45:00', '00:45:00', '00:00:30', '00:00:30'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #06', () => {\n    const expected = '00:00:00'\n    const received = calculateTime(['02:00:00', '03:00:00', '02:00:00'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #07', () => {\n    const expected = '05:02:01'\n    const received = calculateTime(['01:01:01', '09:59:59', '01:01:01'])\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #08', () => {\n    const expected = '-00:00:01'\n    const received = calculateTime(['01:01:01', '03:59:59', '01:01:01', '00:57:58'])\n    assertEquals(received, expected)\n})\n"
    },
    14: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { maxGifts } from '../in/14.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(maxGifts, Function)\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(maxGifts([1, 2, 3, 1]), 4)\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(maxGifts([2, 7, 9, 3, 1]), 12)\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(maxGifts([0, 0, 0, 0, 1]), 1)\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(maxGifts([100]), 100)\n})\n\nDeno.test('Test #06', () => {\n    assertEquals(maxGifts([1, 1, 1]), 2)\n})\n\nDeno.test('Test #07', () => {\n    assertEquals(maxGifts([3, 4, 5]), 8)\n})\n\nDeno.test('Test #08', () => {\n    assertEquals(maxGifts([99]), 99)\n})\n\n// These tests below are not in the original challenge, its from the channel\n// discussion on Discord.\nDeno.test('Test #09', () => {\n    assertEquals(maxGifts([5, 1, 1, 5]), 10)\n})\n\n// https://discord.com/channels/741237973663612969/915910832259477534\nDeno.test('Test #10', () => {\n    assertEquals(maxGifts([4, 1, 1, 4, 2, 1]), 9)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { maxGifts } from '../in/14.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(maxGifts, Function)\n})\n\nDeno.test('Test #02', () => {\n    assertEquals(maxGifts([1, 2, 3, 1]), 4)\n})\n\nDeno.test('Test #03', () => {\n    assertEquals(maxGifts([2, 7, 9, 3, 1]), 12)\n})\n\nDeno.test('Test #04', () => {\n    assertEquals(maxGifts([0, 0, 0, 0, 1]), 1)\n})\n\nDeno.test('Test #05', () => {\n    assertEquals(maxGifts([100]), 100)\n})\n\nDeno.test('Test #06', () => {\n    assertEquals(maxGifts([1, 1, 1]), 2)\n})\n\nDeno.test('Test #07', () => {\n    assertEquals(maxGifts([3, 4, 5]), 8)\n})\n\nDeno.test('Test #08', () => {\n    assertEquals(maxGifts([99]), 99)\n})\n\n// These tests below are not in the original challenge, its from the channel\n// discussion on Discord.\nDeno.test('Test #09', () => {\n    assertEquals(maxGifts([5, 1, 1, 5]), 10)\n})\n\n// https://discord.com/channels/741237973663612969/915910832259477534\nDeno.test('Test #10', () => {\n    assertEquals(maxGifts([4, 1, 1, 4, 2, 1]), 9)\n})\n"
    },
    15: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { autonomousDrive } from '../in/15.ts'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(autonomousDrive, Function)\n})\n\nDeno.test('Test #02', () => {\n    const received = autonomousDrive(['..!....'], ['R', 'L'])\n    const expected = [\n        '..!....'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #03', () => {\n    const received = autonomousDrive(['!..', '***'], ['U', 'L'])\n    const expected = [\n        '!..',\n        '***'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #04', () => {\n    const received = autonomousDrive([\n        '..!....',\n        '......*'\n    ], ['R', 'D', 'L'])\n    const expected = [\n        '.......',\n        '..!...*'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #05', () => {\n    const received = autonomousDrive([\n        '*..!..*',\n        '*.....*'\n    ], ['R', 'R', 'R', 'D', 'D'])\n    const expected = [\n        '*.....*',\n        '*....!*'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #06', () => {\n    const received = autonomousDrive(['***', '.!.', '***'], ['D', 'U', 'R', 'R', 'R'])\n    const expected = [\n        '***',\n        '..!',\n        '***'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #07', () => {\n    const received = autonomousDrive(['***', '*!*', '***'], ['D', 'U', 'R', 'L'])\n    const expected = [\n        '***',\n        '*!*',\n        '***'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #08', () => {\n    const received = autonomousDrive([\n        '.**.*.*.',\n        '.***....',\n        '..!.....'\n    ], ['D', 'U', 'R', 'R', 'R'])\n    const expected = [\n        '.**.*.*.',\n        '.***....',\n        '.....!..'\n    ]\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { autonomousDrive } from '../in/15.js'\n\nDeno.test('Test #01', () => {\n    assertInstanceOf(autonomousDrive, Function)\n})\n\nDeno.test('Test #02', () => {\n    const received = autonomousDrive(['..!....'], ['R', 'L'])\n    const expected = [\n        '..!....'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #03', () => {\n    const received = autonomousDrive(['!..', '***'], ['U', 'L'])\n    const expected = [\n        '!..',\n        '***'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #04', () => {\n    const received = autonomousDrive([\n        '..!....',\n        '......*'\n    ], ['R', 'D', 'L'])\n    const expected = [\n        '.......',\n        '..!...*'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #05', () => {\n    const received = autonomousDrive([\n        '*..!..*',\n        '*.....*'\n    ], ['R', 'R', 'R', 'D', 'D'])\n    const expected = [\n        '*.....*',\n        '*....!*'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #06', () => {\n    const received = autonomousDrive(['***', '.!.', '***'], ['D', 'U', 'R', 'R', 'R'])\n    const expected = [\n        '***',\n        '..!',\n        '***'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #07', () => {\n    const received = autonomousDrive(['***', '*!*', '***'], ['D', 'U', 'R', 'L'])\n    const expected = [\n        '***',\n        '*!*',\n        '***'\n    ]\n    assertEquals(received, expected)\n})\n\nDeno.test('Test #08', () => {\n    const received = autonomousDrive([\n        '.**.*.*.',\n        '.***....',\n        '..!.....'\n    ], ['D', 'U', 'R', 'R', 'R'])\n    const expected = [\n        '.**.*.*.',\n        '.***....',\n        '.....!..'\n    ]\n    assertEquals(received, expected)\n})\n"
    },
    16: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { transformTree } from '../in/16.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(transformTree, Function)\n})\n\ntest('Test #02', () => {\n    const received = transformTree([])\n    const expected = null\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = transformTree([1])\n    const expected = {\n        value: 1,\n        left: null,\n        right: null\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = transformTree([1, 2, 3])\n    const expected = {\n        value: 1,\n        left: {\n            value: 2,\n            left: null,\n            right: null\n        },\n        right: {\n            value: 3,\n            left: null,\n            right: null\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = transformTree([1, 2, 3, 4, 5])\n    const expected = {\n        value: 1,\n        left: {\n            value: 2,\n            left: {\n                value: 4,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 5,\n                left: null,\n                right: null\n            }\n        },\n        right: {\n            value: 3,\n            left: null,\n            right: null\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = transformTree([1, 2, 3, 4, 5, 6, 7])\n    const expected = {\n        value: 1,\n        left: {\n            value: 2,\n            left: {\n                value: 4,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 5,\n                left: null,\n                right: null\n            }\n        },\n        right: {\n            value: 3,\n            left: {\n                value: 6,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 7,\n                left: null,\n                right: null\n            }\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = transformTree([17, 0, null, null, 1])\n    const expected = {\n        value: 17,\n        left: {\n            value: 0,\n            left: null,\n            right: {\n                value: 1,\n                left: null,\n                right: null\n            }\n        },\n        right: null\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = transformTree([3, 1, 0, 8, 12, null, 1])\n    const expected = {\n        value: 3,\n        left: {\n            value: 1,\n            left: {\n                value: 8,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 12,\n                left: null,\n                right: null\n            }\n        },\n        right: {\n            value: 0,\n            left: null,\n            right: {\n                value: 1,\n                left: null,\n                right: null\n            }\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #09', () => {\n    const received = transformTree([2, 7, 5, null, 6, null, 9, null, null, 1, 11, null, null, null, 10])\n    const expected = {\n        value: 2,\n        left: {\n            value: 7,\n            left: null,\n            right: {\n                value: 6,\n                left: {\n                    value: 1,\n                    left: null,\n                    right: null\n                },\n                right: {\n                    value: 11,\n                    left: null,\n                    right: null\n                }\n            }\n        },\n        right: {\n            value: 5,\n            left: null,\n            right: {\n                value: 9,\n                left: null,\n                right: {\n                    value: 10,\n                    left: null,\n                    right: null\n                }\n            }\n        }\n    }\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { transformTree } from '../in/16.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(transformTree, Function)\n})\n\ntest('Test #02', () => {\n    const received = transformTree([])\n    const expected = null\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = transformTree([1])\n    const expected = {\n        value: 1,\n        left: null,\n        right: null\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = transformTree([1, 2, 3])\n    const expected = {\n        value: 1,\n        left: {\n            value: 2,\n            left: null,\n            right: null\n        },\n        right: {\n            value: 3,\n            left: null,\n            right: null\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = transformTree([1, 2, 3, 4, 5])\n    const expected = {\n        value: 1,\n        left: {\n            value: 2,\n            left: {\n                value: 4,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 5,\n                left: null,\n                right: null\n            }\n        },\n        right: {\n            value: 3,\n            left: null,\n            right: null\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = transformTree([1, 2, 3, 4, 5, 6, 7])\n    const expected = {\n        value: 1,\n        left: {\n            value: 2,\n            left: {\n                value: 4,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 5,\n                left: null,\n                right: null\n            }\n        },\n        right: {\n            value: 3,\n            left: {\n                value: 6,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 7,\n                left: null,\n                right: null\n            }\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = transformTree([17, 0, null, null, 1])\n    const expected = {\n        value: 17,\n        left: {\n            value: 0,\n            left: null,\n            right: {\n                value: 1,\n                left: null,\n                right: null\n            }\n        },\n        right: null\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = transformTree([3, 1, 0, 8, 12, null, 1])\n    const expected = {\n        value: 3,\n        left: {\n            value: 1,\n            left: {\n                value: 8,\n                left: null,\n                right: null\n            },\n            right: {\n                value: 12,\n                left: null,\n                right: null\n            }\n        },\n        right: {\n            value: 0,\n            left: null,\n            right: {\n                value: 1,\n                left: null,\n                right: null\n            }\n        }\n    }\n    assertEquals(received, expected)\n})\n\ntest('Test #09', () => {\n    const received = transformTree([2, 7, 5, null, 6, null, 9, null, null, 1, 11, null, null, null, 10])\n    const expected = {\n        value: 2,\n        left: {\n            value: 7,\n            left: null,\n            right: {\n                value: 6,\n                left: {\n                    value: 1,\n                    left: null,\n                    right: null\n                },\n                right: {\n                    value: 11,\n                    left: null,\n                    right: null\n                }\n            }\n        },\n        right: {\n            value: 5,\n            left: null,\n            right: {\n                value: 9,\n                left: null,\n                right: {\n                    value: 10,\n                    left: null,\n                    right: null\n                }\n            }\n        }\n    }\n    assertEquals(received, expected)\n})\n"
    },
    17: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { optimizeIntervals } from '../in/17.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(optimizeIntervals, Function)\n})\n\ntest('Test #02', () => {\n    const received = optimizeIntervals([[2, 7], [3, 4], [5, 8]])\n    const expected = [\n        [\n            2,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = optimizeIntervals([[3, 4], [5, 8], [2, 7]])\n    const expected = [\n        [\n            2,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = optimizeIntervals([[1, 3], [2, 6], [8, 10]])\n    const expected = [\n        [\n            1,\n            6\n        ],\n        [\n            8,\n            10\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = optimizeIntervals([[1, 2], [3, 4], [5, 6]])\n    const expected = [\n        [\n            1,\n            2\n        ],\n        [\n            3,\n            4\n        ],\n        [\n            5,\n            6\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = optimizeIntervals([[5, 7], [6, 8]])\n    const expected = [\n        [\n            5,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = optimizeIntervals([[1, 5], [6, 10], [11, 15], [16, 20]])\n    const expected = [\n        [\n            1,\n            5\n        ],\n        [\n            6,\n            10\n        ],\n        [\n            11,\n            15\n        ],\n        [\n            16,\n            20\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = optimizeIntervals([[1, 15], [8, 12], [4, 7]])\n    const expected = [\n        [\n            1,\n            15\n        ]\n    ]\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { optimizeIntervals } from '../in/17.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(optimizeIntervals, Function)\n})\n\ntest('Test #02', () => {\n    const received = optimizeIntervals([[2, 7], [3, 4], [5, 8]])\n    const expected = [\n        [\n            2,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = optimizeIntervals([[3, 4], [5, 8], [2, 7]])\n    const expected = [\n        [\n            2,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = optimizeIntervals([[1, 3], [2, 6], [8, 10]])\n    const expected = [\n        [\n            1,\n            6\n        ],\n        [\n            8,\n            10\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = optimizeIntervals([[1, 2], [3, 4], [5, 6]])\n    const expected = [\n        [\n            1,\n            2\n        ],\n        [\n            3,\n            4\n        ],\n        [\n            5,\n            6\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = optimizeIntervals([[5, 7], [6, 8]])\n    const expected = [\n        [\n            5,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = optimizeIntervals([[1, 5], [6, 10], [11, 15], [16, 20]])\n    const expected = [\n        [\n            1,\n            5\n        ],\n        [\n            6,\n            10\n        ],\n        [\n            11,\n            15\n        ],\n        [\n            16,\n            20\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = optimizeIntervals([[1, 15], [8, 12], [4, 7]])\n    const expected = [\n        [\n            1,\n            15\n        ]\n    ]\n    assertEquals(received, expected)\n})\n"
    },
    18: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { drawClock } from '../in/18.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(drawClock, Function)\n})\n\ntest('Test #02', () => {\n    const expected = [\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('01:30')\n    assertEquals(received, expected)\n})\ntest('Test #03', () => {\n    const expected = [\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' '\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' '\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('23:45')\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const expected = [\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('16:48')\n    assertEquals(received, expected)\n})\ntest('Test #05', () => {\n    const expected = [\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('17:39')\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const expected = [\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ]\n    ]\n    const received = drawClock('00:21')\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { drawClock } from '../in/18.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(drawClock, Function)\n})\n\ntest('Test #02', () => {\n    const expected = [\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('01:30')\n    assertEquals(received, expected)\n})\ntest('Test #03', () => {\n    const expected = [\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' '\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' '\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('23:45')\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const expected = [\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('16:48')\n    assertEquals(received, expected)\n})\ntest('Test #05', () => {\n    const expected = [\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    const received = drawClock('17:39')\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const expected = [\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*',\n            '*',\n            '*',\n            ' ',\n            ' ',\n            ' ',\n            '*'\n        ]\n    ]\n    const received = drawClock('00:21')\n    assertEquals(received, expected)\n})\n"
    },
    19: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { revealSabotage } from '../in/19.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(revealSabotage, Function)\n})\n\ntest('Test #02', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' ', ' '],\n        [' ', ' ', '*', ' '],\n        [' ', ' ', ' ', ' '],\n        ['*', ' ', ' ', ' ']\n    ])\n    const expected = [\n        [\n            '*',\n            '2',\n            '1',\n            '1'\n        ],\n        [\n            '1',\n            '2',\n            '*',\n            '1'\n        ],\n        [\n            '1',\n            '2',\n            '1',\n            '1'\n        ],\n        [\n            '*',\n            '1',\n            ' ',\n            ' '\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = revealSabotage([\n        [' ', ' ', ' '],\n        [' ', '*', ' '],\n        [' ', ' ', ' ']\n    ])\n    const expected = [\n        [\n            '1',\n            '1',\n            '1'\n        ],\n        [\n            '1',\n            '*',\n            '1'\n        ],\n        [\n            '1',\n            '1',\n            '1'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' '],\n        [' ', '*', ' '],\n        [' ', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '2',\n            '1'\n        ],\n        [\n            '2',\n            '*',\n            '2'\n        ],\n        [\n            '1',\n            '2',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' '],\n        [' ', ' ', ' '],\n        [' ', ' ', ' ']\n    ])\n    const expected = [\n        [\n            '*',\n            '1',\n            ' '\n        ],\n        [\n            '1',\n            '1',\n            ' '\n        ],\n        [\n            ' ',\n            ' ',\n            ' '\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = revealSabotage([\n        ['*', '*', '*'],\n        ['*', ' ', '*'],\n        ['*', '*', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            '*',\n            '8',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = revealSabotage([\n        ['*', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '2',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' '],\n        [' ', ' ', ' '],\n        [' ', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '1',\n            ' '\n        ],\n        [\n            '1',\n            '2',\n            '1'\n        ],\n        [\n            ' ',\n            '1',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #09', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' ', ' ', ' '],\n        [' ', ' ', ' ', ' ', ' '],\n        [' ', ' ', '*', ' ', ' '],\n        [' ', ' ', ' ', ' ', ' '],\n        [' ', ' ', ' ', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '1',\n            ' ',\n            ' ',\n            ' '\n        ],\n        [\n            '1',\n            '2',\n            '1',\n            '1',\n            ' '\n        ],\n        [\n            ' ',\n            '1',\n            '*',\n            '1',\n            ' '\n        ],\n        [\n            ' ',\n            '1',\n            '1',\n            '2',\n            '1'\n        ],\n        [\n            ' ',\n            ' ',\n            ' ',\n            '1',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { revealSabotage } from '../in/19.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(revealSabotage, Function)\n})\n\ntest('Test #02', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' ', ' '],\n        [' ', ' ', '*', ' '],\n        [' ', ' ', ' ', ' '],\n        ['*', ' ', ' ', ' ']\n    ])\n    const expected = [\n        [\n            '*',\n            '2',\n            '1',\n            '1'\n        ],\n        [\n            '1',\n            '2',\n            '*',\n            '1'\n        ],\n        [\n            '1',\n            '2',\n            '1',\n            '1'\n        ],\n        [\n            '*',\n            '1',\n            ' ',\n            ' '\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = revealSabotage([\n        [' ', ' ', ' '],\n        [' ', '*', ' '],\n        [' ', ' ', ' ']\n    ])\n    const expected = [\n        [\n            '1',\n            '1',\n            '1'\n        ],\n        [\n            '1',\n            '*',\n            '1'\n        ],\n        [\n            '1',\n            '1',\n            '1'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' '],\n        [' ', '*', ' '],\n        [' ', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '2',\n            '1'\n        ],\n        [\n            '2',\n            '*',\n            '2'\n        ],\n        [\n            '1',\n            '2',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' '],\n        [' ', ' ', ' '],\n        [' ', ' ', ' ']\n    ])\n    const expected = [\n        [\n            '*',\n            '1',\n            ' '\n        ],\n        [\n            '1',\n            '1',\n            ' '\n        ],\n        [\n            ' ',\n            ' ',\n            ' '\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = revealSabotage([\n        ['*', '*', '*'],\n        ['*', ' ', '*'],\n        ['*', '*', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '*',\n            '*'\n        ],\n        [\n            '*',\n            '8',\n            '*'\n        ],\n        [\n            '*',\n            '*',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = revealSabotage([\n        ['*', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '2',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' '],\n        [' ', ' ', ' '],\n        [' ', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '1',\n            ' '\n        ],\n        [\n            '1',\n            '2',\n            '1'\n        ],\n        [\n            ' ',\n            '1',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #09', () => {\n    const received = revealSabotage([\n        ['*', ' ', ' ', ' ', ' '],\n        [' ', ' ', ' ', ' ', ' '],\n        [' ', ' ', '*', ' ', ' '],\n        [' ', ' ', ' ', ' ', ' '],\n        [' ', ' ', ' ', ' ', '*']\n    ])\n    const expected = [\n        [\n            '*',\n            '1',\n            ' ',\n            ' ',\n            ' '\n        ],\n        [\n            '1',\n            '2',\n            '1',\n            '1',\n            ' '\n        ],\n        [\n            ' ',\n            '1',\n            '*',\n            '1',\n            ' '\n        ],\n        [\n            ' ',\n            '1',\n            '1',\n            '2',\n            '1'\n        ],\n        [\n            ' ',\n            ' ',\n            ' ',\n            '1',\n            '*'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n"
    },
    20: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { distributeGifts } from '../in/20.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(distributeGifts, Function)\n})\n\ntest('Test #02', () => {\n    const received = distributeGifts([\n        [4, 5, 1],\n        [6, null, 3],\n        [8, null, 4]\n    ])\n    const expected = [\n        [\n            5,\n            3,\n            3\n        ],\n        [\n            6,\n            5,\n            3\n        ],\n        [\n            7,\n            6,\n            4\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = distributeGifts([\n        [2, null],\n        [null, 3]\n    ])\n    const expected = [\n        [\n            2,\n            3\n        ],\n        [\n            3,\n            3\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = distributeGifts([\n        [2, 1, 1],\n        [3, 4, null]\n    ])\n    const expected = [\n        [\n            2,\n            2,\n            1\n        ],\n        [\n            3,\n            3,\n            3\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = distributeGifts([\n        [null, 5],\n        [3, null]\n    ])\n    const expected = [\n        [\n            4,\n            5\n        ],\n        [\n            3,\n            4\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = distributeGifts([\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ])\n    const expected = [\n        [\n            2,\n            3,\n            4\n        ],\n        [\n            4,\n            5,\n            6\n        ],\n        [\n            6,\n            7,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = distributeGifts([\n        [null, 1, null, 1, null],\n        [1, null, 1, null, 1]\n    ])\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { distributeGifts } from '../in/20.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(distributeGifts, Function)\n})\n\ntest('Test #02', () => {\n    const received = distributeGifts([\n        [4, 5, 1],\n        [6, null, 3],\n        [8, null, 4]\n    ])\n    const expected = [\n        [\n            5,\n            3,\n            3\n        ],\n        [\n            6,\n            5,\n            3\n        ],\n        [\n            7,\n            6,\n            4\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = distributeGifts([\n        [2, null],\n        [null, 3]\n    ])\n    const expected = [\n        [\n            2,\n            3\n        ],\n        [\n            3,\n            3\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = distributeGifts([\n        [2, 1, 1],\n        [3, 4, null]\n    ])\n    const expected = [\n        [\n            2,\n            2,\n            1\n        ],\n        [\n            3,\n            3,\n            3\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = distributeGifts([\n        [null, 5],\n        [3, null]\n    ])\n    const expected = [\n        [\n            4,\n            5\n        ],\n        [\n            3,\n            4\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = distributeGifts([\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ])\n    const expected = [\n        [\n            2,\n            3,\n            4\n        ],\n        [\n            4,\n            5,\n            6\n        ],\n        [\n            6,\n            7,\n            8\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = distributeGifts([\n        [null, 1, null, 1, null],\n        [1, null, 1, null, 1]\n    ])\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n"
    },
    21: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { findBalancedSegment } from '../in/21.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(findBalancedSegment, Function)\n})\n\ntest('Test #02', () => {\n    const received = findBalancedSegment([1, 1, 0, 1, 1, 0, 1, 1])\n    const expected = [\n        2,\n        5\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = findBalancedSegment([1, 1, 0])\n    const expected = [\n        1,\n        2\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = findBalancedSegment([1, 1, 1])\n    const expected: number[] = []\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = findBalancedSegment([1, 0, 1])\n    const expected = [\n        0,\n        1\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = findBalancedSegment([1, 0, 1, 0])\n    const expected = [\n        0,\n        3\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = findBalancedSegment([1, 1, 0, 1, 0, 1])\n    const expected: number[] = [\n        1,\n        4\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = findBalancedSegment([1, 0, 0, 0, 1, 1, 1, 0, 0, 0])\n    const expected = [\n        0,\n        7\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = findBalancedSegment([0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1])\n    const expected = [\n        5,\n        10\n    ]\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { findBalancedSegment } from '../in/21.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(findBalancedSegment, Function)\n})\n\ntest('Test #02', () => {\n    const received = findBalancedSegment([1, 1, 0, 1, 1, 0, 1, 1])\n    const expected = [\n        2,\n        5\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = findBalancedSegment([1, 1, 0])\n    const expected = [\n        1,\n        2\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = findBalancedSegment([1, 1, 1])\n    const expected: number[] = []\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = findBalancedSegment([1, 0, 1])\n    const expected = [\n        0,\n        1\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = findBalancedSegment([1, 0, 1, 0])\n    const expected = [\n        0,\n        3\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = findBalancedSegment([1, 1, 0, 1, 0, 1])\n    const expected: number[] = [\n        1,\n        4\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = findBalancedSegment([1, 0, 0, 0, 1, 1, 1, 0, 0, 0])\n    const expected = [\n        0,\n        7\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = findBalancedSegment([0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1])\n    const expected = [\n        5,\n        10\n    ]\n    assertEquals(received, expected)\n})\n"
    },
    22: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { compile } from '../in/22.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(compile, Function)\n})\n\ntest('Test #02', () => {\n    const received = compile('++*-')\n    const expected = 3\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = compile('++¬ø+?')\n    const expected = 3\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = compile('-+¬ø+?')\n    const expected = 0\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = compile('++*¬ø-?')\n    const expected = 3\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = compile('++%++<')\n    const expected = 6\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = compile('++%++<++¬ø*?')\n    const expected = 16\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = compile('++¬ø+?¬ø+?¬ø+?')\n    const expected = 5\n    assertEquals(received, expected)\n})\n\ntest('Test #09', () => {\n    const received = compile('--¬ø+++?')\n    const expected = -2\n    assertEquals(received, expected)\n})\n\ntest('Test #10', () => {\n    const received = compile('--¬ø+++?+++¬ø--?')\n    const expected = -1\n    assertEquals(received, expected)\n})\n\ntest('Test #11', () => {\n    const received = compile('<%+¬ø++%++<?')\n    const expected = 7\n    assertEquals(received, expected)\n})\n\ntest('Test #12', () => {\n    const received = compile('<<<<<<+<<<<<+%')\n    const expected = 2\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { compile } from '../in/22.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(compile, Function)\n})\n\ntest('Test #02', () => {\n    const received = compile('++*-')\n    const expected = 3\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = compile('++¬ø+?')\n    const expected = 3\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = compile('-+¬ø+?')\n    const expected = 0\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = compile('++*¬ø-?')\n    const expected = 3\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = compile('++%++<')\n    const expected = 6\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = compile('++%++<++¬ø*?')\n    const expected = 16\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = compile('++¬ø+?¬ø+?¬ø+?')\n    const expected = 5\n    assertEquals(received, expected)\n})\n\ntest('Test #09', () => {\n    const received = compile('--¬ø+++?')\n    const expected = -2\n    assertEquals(received, expected)\n})\n\ntest('Test #10', () => {\n    const received = compile('--¬ø+++?+++¬ø--?')\n    const expected = -1\n    assertEquals(received, expected)\n})\n\ntest('Test #11', () => {\n    const received = compile('<%+¬ø++%++<?')\n    const expected = 7\n    assertEquals(received, expected)\n})\n\ntest('Test #12', () => {\n    const received = compile('<<<<<<+<<<<<+%')\n    const expected = 2\n    assertEquals(received, expected)\n})\n"
    },
    23: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { organizeChristmasDinner } from '../in/23.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(organizeChristmasDinner, Function)\n})\n\ntest('Test #02', () => {\n    const received = organizeChristmasDinner([\n        ['christmas turkey', 'turkey', 'sauce', 'herbs'],\n        ['cake', 'flour', 'sugar', 'egg'],\n        ['hot chocolate', 'chocolate', 'milk', 'sugar'],\n        ['pizza', 'sauce', 'tomato', 'cheese', 'ham']\n    ])\n    const expected = [\n        [\n            'sauce',\n            'christmas turkey',\n            'pizza'\n        ],\n        [\n            'sugar',\n            'cake',\n            'hot chocolate'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = organizeChristmasDinner([\n        ['fruit salad', 'apple', 'banana', 'orange'],\n        ['berry smoothie', 'blueberry', 'banana', 'milk'],\n        ['apple pie', 'apple', 'sugar', 'flour']\n    ])\n    const expected = [\n        [\n            'apple',\n            'apple pie',\n            'fruit salad'\n        ],\n        [\n            'banana',\n            'berry smoothie',\n            'fruit salad'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = organizeChristmasDinner([\n        ['gingerbread', 'flour', 'ginger', 'sugar'],\n        ['glazed ham', 'ham', 'honey', 'sugar', 'vinegar'],\n        ['roast chicken', 'chicken', 'rosemary', 'thyme', 'garlic'],\n        ['vegetable soup', 'carrot', 'potato', 'onion', 'garlic'],\n        ['fruit punch', 'apple juice', 'orange juice', 'sugar']\n    ])\n    const expected = [\n        [\n            'garlic',\n            'roast chicken',\n            'vegetable soup'\n        ],\n        [\n            'sugar',\n            'fruit punch',\n            'gingerbread',\n            'glazed ham'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = organizeChristmasDinner([\n        ['pumpkin pie', 'pumpkin', 'cinnamon', 'sugar', 'flour'],\n        ['mashed potatoes', 'potatoes', 'butter', 'milk'],\n        ['cinnamon rolls', 'flour', 'cinnamon', 'butter', 'sugar'],\n        ['turkey stuffing', 'bread crumbs', 'celery', 'onion', 'butter']\n    ])\n    const expected = [\n        [\n            'butter',\n            'cinnamon rolls',\n            'mashed potatoes',\n            'turkey stuffing'\n        ],\n        [\n            'cinnamon',\n            'cinnamon rolls',\n            'pumpkin pie'\n        ],\n        [\n            'flour',\n            'cinnamon rolls',\n            'pumpkin pie'\n        ],\n        [\n            'sugar',\n            'cinnamon rolls',\n            'pumpkin pie'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = organizeChristmasDinner([\n        ['chicken alfredo', 'chicken', 'pasta', 'parmesan'],\n        ['parmesan chicken', 'chicken', 'parmesan', 'bread crumbs'],\n        ['pasta salad', 'pasta', 'olive oil', 'tomato'],\n        ['tomato soup', 'tomato', 'basil', 'cream']\n    ])\n    const expected = [\n        [\n            'chicken',\n            'chicken alfredo',\n            'parmesan chicken'\n        ],\n        [\n            'parmesan',\n            'chicken alfredo',\n            'parmesan chicken'\n        ],\n        [\n            'pasta',\n            'chicken alfredo',\n            'pasta salad'\n        ],\n        [\n            'tomato',\n            'pasta salad',\n            'tomato soup'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = organizeChristmasDinner([\n        ['snowflake cookies', 'flour', 'sugar', 'vanilla'],\n        ['winter stew', 'beef', 'carrots', 'potatoes'],\n        ['holiday punch', 'cranberry juice', 'orange juice', 'sparkling water'],\n        ['festive salad', 'lettuce', 'cranberries', 'walnuts']\n    ])\n    const expected: string[][] = []\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { organizeChristmasDinner } from '../in/23.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(organizeChristmasDinner, Function)\n})\n\ntest('Test #02', () => {\n    const received = organizeChristmasDinner([\n        ['christmas turkey', 'turkey', 'sauce', 'herbs'],\n        ['cake', 'flour', 'sugar', 'egg'],\n        ['hot chocolate', 'chocolate', 'milk', 'sugar'],\n        ['pizza', 'sauce', 'tomato', 'cheese', 'ham']\n    ])\n    const expected = [\n        [\n            'sauce',\n            'christmas turkey',\n            'pizza'\n        ],\n        [\n            'sugar',\n            'cake',\n            'hot chocolate'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = organizeChristmasDinner([\n        ['fruit salad', 'apple', 'banana', 'orange'],\n        ['berry smoothie', 'blueberry', 'banana', 'milk'],\n        ['apple pie', 'apple', 'sugar', 'flour']\n    ])\n    const expected = [\n        [\n            'apple',\n            'apple pie',\n            'fruit salad'\n        ],\n        [\n            'banana',\n            'berry smoothie',\n            'fruit salad'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = organizeChristmasDinner([\n        ['gingerbread', 'flour', 'ginger', 'sugar'],\n        ['glazed ham', 'ham', 'honey', 'sugar', 'vinegar'],\n        ['roast chicken', 'chicken', 'rosemary', 'thyme', 'garlic'],\n        ['vegetable soup', 'carrot', 'potato', 'onion', 'garlic'],\n        ['fruit punch', 'apple juice', 'orange juice', 'sugar']\n    ])\n    const expected = [\n        [\n            'garlic',\n            'roast chicken',\n            'vegetable soup'\n        ],\n        [\n            'sugar',\n            'fruit punch',\n            'gingerbread',\n            'glazed ham'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = organizeChristmasDinner([\n        ['pumpkin pie', 'pumpkin', 'cinnamon', 'sugar', 'flour'],\n        ['mashed potatoes', 'potatoes', 'butter', 'milk'],\n        ['cinnamon rolls', 'flour', 'cinnamon', 'butter', 'sugar'],\n        ['turkey stuffing', 'bread crumbs', 'celery', 'onion', 'butter']\n    ])\n    const expected = [\n        [\n            'butter',\n            'cinnamon rolls',\n            'mashed potatoes',\n            'turkey stuffing'\n        ],\n        [\n            'cinnamon',\n            'cinnamon rolls',\n            'pumpkin pie'\n        ],\n        [\n            'flour',\n            'cinnamon rolls',\n            'pumpkin pie'\n        ],\n        [\n            'sugar',\n            'cinnamon rolls',\n            'pumpkin pie'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = organizeChristmasDinner([\n        ['chicken alfredo', 'chicken', 'pasta', 'parmesan'],\n        ['parmesan chicken', 'chicken', 'parmesan', 'bread crumbs'],\n        ['pasta salad', 'pasta', 'olive oil', 'tomato'],\n        ['tomato soup', 'tomato', 'basil', 'cream']\n    ])\n    const expected = [\n        [\n            'chicken',\n            'chicken alfredo',\n            'parmesan chicken'\n        ],\n        [\n            'parmesan',\n            'chicken alfredo',\n            'parmesan chicken'\n        ],\n        [\n            'pasta',\n            'chicken alfredo',\n            'pasta salad'\n        ],\n        [\n            'tomato',\n            'pasta salad',\n            'tomato soup'\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = organizeChristmasDinner([\n        ['snowflake cookies', 'flour', 'sugar', 'vanilla'],\n        ['winter stew', 'beef', 'carrots', 'potatoes'],\n        ['holiday punch', 'cranberry juice', 'orange juice', 'sparkling water'],\n        ['festive salad', 'lettuce', 'cranberries', 'walnuts']\n    ])\n    const expected: string[][] = []\n    assertEquals(received, expected)\n})\n"
    },
    24: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { getStaircasePaths } from '../in/24.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(getStaircasePaths, Function)\n})\n\ntest('Test #02', () => {\n    const received = getStaircasePaths(4, 2)\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            2,\n            1\n        ],\n        [\n            2,\n            1,\n            1\n        ],\n        [\n            2,\n            2\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = getStaircasePaths(0, 0)\n    const expected = [\n        []\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = getStaircasePaths(1, 1)\n    const expected = [\n        [\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = getStaircasePaths(7, 3)\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            2,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            3\n        ],\n        [\n            1,\n            1,\n            1,\n            2,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            2,\n            2\n        ],\n        [\n            1,\n            1,\n            1,\n            3,\n            1\n        ],\n        [\n            1,\n            1,\n            2,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            2,\n            1,\n            2\n        ],\n        [\n            1,\n            1,\n            2,\n            2,\n            1\n        ],\n        [\n            1,\n            1,\n            2,\n            3\n        ],\n        [\n            1,\n            1,\n            3,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            3,\n            2\n        ],\n        [\n            1,\n            2,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            2,\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            2,\n            1,\n            2,\n            1\n        ],\n        [\n            1,\n            2,\n            1,\n            3\n        ],\n        [\n            1,\n            2,\n            2,\n            1,\n            1\n        ],\n        [\n            1,\n            2,\n            2,\n            2\n        ],\n        [\n            1,\n            2,\n            3,\n            1\n        ],\n        [\n            1,\n            3,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            3,\n            1,\n            2\n        ],\n        [\n            1,\n            3,\n            2,\n            1\n        ],\n        [\n            1,\n            3,\n            3\n        ],\n        [\n            2,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            2,\n            1,\n            1,\n            1,\n            2\n        ],\n        [\n            2,\n            1,\n            1,\n            2,\n            1\n        ],\n        [\n            2,\n            1,\n            1,\n            3\n        ],\n        [\n            2,\n            1,\n            2,\n            1,\n            1\n        ],\n        [\n            2,\n            1,\n            2,\n            2\n        ],\n        [\n            2,\n            1,\n            3,\n            1\n        ],\n        [\n            2,\n            2,\n            1,\n            1,\n            1\n        ],\n        [\n            2,\n            2,\n            1,\n            2\n        ],\n        [\n            2,\n            2,\n            2,\n            1\n        ],\n        [\n            2,\n            2,\n            3\n        ],\n        [\n            2,\n            3,\n            1,\n            1\n        ],\n        [\n            2,\n            3,\n            2\n        ],\n        [\n            3,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            3,\n            1,\n            1,\n            2\n        ],\n        [\n            3,\n            1,\n            2,\n            1\n        ],\n        [\n            3,\n            1,\n            3\n        ],\n        [\n            3,\n            2,\n            1,\n            1\n        ],\n        [\n            3,\n            2,\n            2\n        ],\n        [\n            3,\n            3,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = getStaircasePaths(3, 3)\n    const expected = [\n        [\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            2,\n            1\n        ],\n        [\n            3\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = getStaircasePaths(2, 1)\n    const expected = [\n        [\n            1,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = getStaircasePaths(5, 2)\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            1,\n            2,\n            1\n        ],\n        [\n            1,\n            2,\n            1,\n            1\n        ],\n        [\n            1,\n            2,\n            2\n        ],\n        [\n            2,\n            1,\n            1,\n            1\n        ],\n        [\n            2,\n            1,\n            2\n        ],\n        [\n            2,\n            2,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { getStaircasePaths } from '../in/24.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(getStaircasePaths, Function)\n})\n\ntest('Test #02', () => {\n    const received = getStaircasePaths(4, 2)\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            2,\n            1\n        ],\n        [\n            2,\n            1,\n            1\n        ],\n        [\n            2,\n            2\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = getStaircasePaths(0, 0)\n    const expected = [\n        []\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = getStaircasePaths(1, 1)\n    const expected = [\n        [\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = getStaircasePaths(7, 3)\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            2,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            1,\n            3\n        ],\n        [\n            1,\n            1,\n            1,\n            2,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            2,\n            2\n        ],\n        [\n            1,\n            1,\n            1,\n            3,\n            1\n        ],\n        [\n            1,\n            1,\n            2,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            2,\n            1,\n            2\n        ],\n        [\n            1,\n            1,\n            2,\n            2,\n            1\n        ],\n        [\n            1,\n            1,\n            2,\n            3\n        ],\n        [\n            1,\n            1,\n            3,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            3,\n            2\n        ],\n        [\n            1,\n            2,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            2,\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            2,\n            1,\n            2,\n            1\n        ],\n        [\n            1,\n            2,\n            1,\n            3\n        ],\n        [\n            1,\n            2,\n            2,\n            1,\n            1\n        ],\n        [\n            1,\n            2,\n            2,\n            2\n        ],\n        [\n            1,\n            2,\n            3,\n            1\n        ],\n        [\n            1,\n            3,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            3,\n            1,\n            2\n        ],\n        [\n            1,\n            3,\n            2,\n            1\n        ],\n        [\n            1,\n            3,\n            3\n        ],\n        [\n            2,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            2,\n            1,\n            1,\n            1,\n            2\n        ],\n        [\n            2,\n            1,\n            1,\n            2,\n            1\n        ],\n        [\n            2,\n            1,\n            1,\n            3\n        ],\n        [\n            2,\n            1,\n            2,\n            1,\n            1\n        ],\n        [\n            2,\n            1,\n            2,\n            2\n        ],\n        [\n            2,\n            1,\n            3,\n            1\n        ],\n        [\n            2,\n            2,\n            1,\n            1,\n            1\n        ],\n        [\n            2,\n            2,\n            1,\n            2\n        ],\n        [\n            2,\n            2,\n            2,\n            1\n        ],\n        [\n            2,\n            2,\n            3\n        ],\n        [\n            2,\n            3,\n            1,\n            1\n        ],\n        [\n            2,\n            3,\n            2\n        ],\n        [\n            3,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            3,\n            1,\n            1,\n            2\n        ],\n        [\n            3,\n            1,\n            2,\n            1\n        ],\n        [\n            3,\n            1,\n            3\n        ],\n        [\n            3,\n            2,\n            1,\n            1\n        ],\n        [\n            3,\n            2,\n            2\n        ],\n        [\n            3,\n            3,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = getStaircasePaths(3, 3)\n    const expected = [\n        [\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            2\n        ],\n        [\n            2,\n            1\n        ],\n        [\n            3\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = getStaircasePaths(2, 1)\n    const expected = [\n        [\n            1,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = getStaircasePaths(5, 2)\n    const expected = [\n        [\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        [\n            1,\n            1,\n            1,\n            2\n        ],\n        [\n            1,\n            1,\n            2,\n            1\n        ],\n        [\n            1,\n            2,\n            1,\n            1\n        ],\n        [\n            1,\n            2,\n            2\n        ],\n        [\n            2,\n            1,\n            1,\n            1\n        ],\n        [\n            2,\n            1,\n            2\n        ],\n        [\n            2,\n            2,\n            1\n        ]\n    ]\n    assertEquals(received, expected)\n})\n"
    },
    25: {
        "ts": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { travelDistance } from '../in/25.ts'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(travelDistance, Function)\n})\n\ntest('Test #02', () => {\n    const received = travelDistance(\n        `.....1....\n..S.......\n..........\n....3.....\n......2...`)\n    const expected = 12\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = travelDistance('..S.1...')\n    const expected = 2\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = travelDistance(\n        `.....2....\n..S.......\n..........\n....1.....\n......3...`\n    )\n    const expected = 13\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = travelDistance(\n        `3....1....\n..S.......\n.........2\n..........\n......4...`\n    )\n    const expected = 31\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = travelDistance('S1')\n    const expected = 1\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = travelDistance('1....S')\n    const expected = 5\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = travelDistance('S12....3')\n    const expected = 7\n    assertEquals(received, expected)\n})\n",
        "js": "import { assertInstanceOf, assertEquals } from \"https://deno.land/std@0.217.0/assert/mod.ts\";\nimport { travelDistance } from '../in/25.js'\n\nconst { test } = Deno\n\ntest('Test #01', () => {\n    assertInstanceOf(travelDistance, Function)\n})\n\ntest('Test #02', () => {\n    const received = travelDistance(\n        `.....1....\n..S.......\n..........\n....3.....\n......2...`)\n    const expected = 12\n    assertEquals(received, expected)\n})\n\ntest('Test #03', () => {\n    const received = travelDistance('..S.1...')\n    const expected = 2\n    assertEquals(received, expected)\n})\n\ntest('Test #04', () => {\n    const received = travelDistance(\n        `.....2....\n..S.......\n..........\n....1.....\n......3...`\n    )\n    const expected = 13\n    assertEquals(received, expected)\n})\n\ntest('Test #05', () => {\n    const received = travelDistance(\n        `3....1....\n..S.......\n.........2\n..........\n......4...`\n    )\n    const expected = 31\n    assertEquals(received, expected)\n})\n\ntest('Test #06', () => {\n    const received = travelDistance('S1')\n    const expected = 1\n    assertEquals(received, expected)\n})\n\ntest('Test #07', () => {\n    const received = travelDistance('1....S')\n    const expected = 5\n    assertEquals(received, expected)\n})\n\ntest('Test #08', () => {\n    const received = travelDistance('S12....3')\n    const expected = 7\n    assertEquals(received, expected)\n})\n"
    }
}
